<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Spicy - Find & Watch Movies & TV Shows</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Spicy">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://api.themoviedb.org" crossorigin>
    <link rel="preconnect" href="https://image.tmdb.org" crossorigin>
    <link rel="dns-prefetch" href="https://primewire.tf">
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">

    <link rel="icon" type="image/png" href="appicon.png">
    <link rel="apple-touch-icon" href="appicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Note: Using Tailwind CDN for simplicity in this static web app.
         For production with build process, consider installing via npm and using PostCSS. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.14.1/cdn.min.js" defer></script>
    <script src="/sources.js"></script>
    <style>
        /* Prevent flash of unstyled content */
        body {
            opacity: 1;
            transition: opacity 0.3s ease-in;
        }

        body.page-transition-out {
            opacity: 0;
        }

        /* Hide scrollbar */
        html,
        body {
            overflow-y: scroll;
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE and Edge */
        }

        html::-webkit-scrollbar,
        body::-webkit-scrollbar {
            display: none;
            /* Chrome, Safari, Opera */
        }
    </style>
    <style>
        /* Extra-large screens (TVs): cap layout width and scale down oversized spacing & type */
        @media (min-width: 1600px) {

            /* Keep the content width reasonable on very wide screens */
            .container {
                max-width: 1200px;
                margin-left: auto;
                margin-right: auto;
                padding-left: 1rem;
                padding-right: 1rem;
            }

            /* Reduce the hero padding and cap hero title/overview so it doesn't grow too large on TVs */
            .hero-content {
                padding: 1rem 1rem 2rem;
            }

            .hero-title {
                font-size: clamp(1.2rem, calc(1rem + 0.5vw), 2rem);
            }

            .hero-overview {
                font-size: clamp(0.8rem, calc(0.75rem + 0.1vw), 0.9rem);
            }

            /* Cap card widths so they don't become overly large on ultra-wide displays */
            .card-fixed {
                max-width: 200px;
                flex: 0 0 160px;
                /* slightly smaller basis on very large screens */
                min-width: 120px;
            }

            /* Reduce search input size for TV */
            .search-input {
                font-size: 1.5rem;
                padding: 1rem 3rem 1rem 1rem;
            }

            /* Reduce modal size for TV */
            .modal-content {
                max-width: 60rem;
            }

            /* Reduce hero carousel height for TV */
            .hero-carousel {
                min-height: 300px;
                max-height: 350px;
            }

            /* Reduce focus border thickness for TV to keep accents visually balanced */
            .tv-focused-section::before {
                border-width: 2px;
            }

            .tv-focused-item {
                border-width: 2px;
            }
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    backgroundColor: {
                        'amoled': '#000000',
                        'amoled-light': '#0A0A0A',
                        'amoled-card': '#121212',
                    },
                    borderColor: {
                        'amoled-border': '#1A1A1A',
                    },
                },
            },
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            max-width: 100vw;
        }

        .search-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 100%;
            padding: 1rem 3rem 1rem 1rem;
            border: none;
            border-bottom: 4px solid #9ca3af;
            background: transparent;
            color: #f9fafb;
            font-size: 1.25rem;
            transition: border-color 0.3s ease;
        }

        @media (min-width: 640px) {
            .search-input {
                padding: 1.5rem 3rem 1.5rem 1rem;
                font-size: 2rem;
            }
        }

        .search-input:focus {
            outline: none;
            border-bottom-color: #3b82f6;
        }

        .search-input::placeholder {
            color: #9ca3af;
        }

        .search-icon,
        .discover-icon {
            position: absolute;
            right: 0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .search-icon {
            right: 3.5rem;
        }

        .discover-icon {
            right: 0.5rem;
        }

        .search-icon:hover,
        .discover-icon:hover {
            color: #7792bd;
        }

        /* Hide discover icon and search icon on mobile devices */
        @media (max-width: 639px) {

            .discover-icon,
            .search-icon {
                display: none;
            }
        }

        @media (min-width: 640px) {

            .search-icon,
            .discover-icon {
                width: 2rem;
                height: 2rem;
            }

            .search-icon {
                right: 4rem;
            }
        }

        .card-hover {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .card-hover::after {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(35deg,
                    rgba(168, 85, 247, 0.4),
                    rgba(168, 85, 247, 0),
                    rgba(139, 92, 246, 0.4));
            border-radius: 0.5rem;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .card-hover:hover {
            /* Remove vertical lift to avoid cards touching the viewport/container edges on hover.
               Keep a slight scale for the hover emphasis. */
            transform: scale(1.02);
            box-shadow: 0 20px 30px -10px rgba(0, 0, 0, 0.5);
        }

        .card-hover:hover::after {
            opacity: 1;
        }

        .card-hover:hover .card-overlay {
            opacity: 1;
            background: linear-gradient(to top,
                    rgba(0, 0, 0, 0.95) 0%,
                    rgba(0, 0, 0, 0.8) 40%,
                    rgba(0, 0, 0, 0.2) 100%);
        }

        .card-overlay {
            opacity: 0;
            transition: all 0.4s ease;
            background: linear-gradient(to top,
                    rgba(0, 0, 0, 0.9) 0%,
                    rgba(0, 0, 0, 0.7) 50%,
                    rgba(0, 0, 0, 0.3) 100%);
        }

        .card-hover:hover .card-overlay {
            opacity: 1;
            background: linear-gradient(to top,
                    rgba(0, 0, 0, 0.95) 0%,
                    rgba(0, 0, 0, 0.8) 40%,
                    rgba(0, 0, 0, 0.2) 100%);
        }

        .card-hover:hover img {
            filter: blur(2px) brightness(0.9);
            transition: all 0.4s ease;
        }

        .card-hover img {
            transition: all 0.4s ease;
        }

        /* TV Mode Styles */
        .tv-focused-section {
            position: relative;
        }

        .tv-focused-section::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 3px solid #ADD8E6;
            border-radius: 0.75rem;
            z-index: 10;
            pointer-events: none;
        }

        .tv-focused-item {
            position: relative;
            border: 2px solid #ADD8E6;
            border-radius: 0.5rem;
            z-index: 10;
        }

        .tv-navigable-item {
            transition: all 0.3s ease;
        }

        .tv-navigable-item.tv-focused-item {
            border: 3px solid #ADD8E6 !important;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-delay-1 {
            animation-delay: 0.1s;
        }

        .fade-in-delay-2 {
            animation-delay: 0.2s;
        }

        .fade-in-delay-3 {
            animation-delay: 0.3s;
        }

        /* Netflix/Hulu/Prime-inspired card animations */
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Page transition animations - removed, now handled by body opacity */

        .card-animate {
            animation: fadeInScale 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        .card-animate-slide-left {
            animation: slideInFromLeft 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        .card-animate-slide-right {
            animation: slideInFromRight 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        /* Staggered animation delays for cards */
        .card-delay-1 {
            animation-delay: 0.05s;
        }

        .card-delay-2 {
            animation-delay: 0.1s;
        }

        .card-delay-3 {
            animation-delay: 0.15s;
        }

        .card-delay-4 {
            animation-delay: 0.2s;
        }

        .card-delay-5 {
            animation-delay: 0.25s;
        }

        .card-delay-6 {
            animation-delay: 0.3s;
        }

        .card-delay-7 {
            animation-delay: 0.35s;
        }

        .card-delay-8 {
            animation-delay: 0.4s;
        }

        .card-delay-9 {
            animation-delay: 0.45s;
        }

        .card-delay-10 {
            animation-delay: 0.5s;
        }

        .card-delay-11 {
            animation-delay: 0.55s;
        }

        .card-delay-12 {
            animation-delay: 0.6s;
        }

        .card-delay-13 {
            animation-delay: 0.65s;
        }

        .card-delay-14 {
            animation-delay: 0.7s;
        }

        .card-delay-15 {
            animation-delay: 0.75s;
        }

        .card-delay-16 {
            animation-delay: 0.8s;
        }

        .card-delay-17 {
            animation-delay: 0.85s;
        }

        .card-delay-18 {
            animation-delay: 0.9s;
        }

        .card-delay-19 {
            animation-delay: 0.95s;
        }

        .card-delay-20 {
            animation-delay: 1s;
        }

        /* Hero Carousel Styles */
        .hero-carousel {
            position: relative;
            width: 100%;
            height: 55vh;
            min-height: 350px;
            max-height: 450px;
            overflow: hidden;
            touch-action: pan-y;
        }

        .hero-slides-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            will-change: transform;
        }

        .hero-slide {
            position: relative;
            flex-shrink: 0;
            width: 100%;
            height: 100%;
            min-width: 100%;
            max-width: 100%;
        }

        .hero-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(0px);
        }

        .hero-gradient {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top,
                    rgba(0, 0, 0, 1) 0%,
                    rgba(0, 0, 0, 1) 10%,
                    rgba(0, 0, 0, 0.95) 25%,
                    rgba(0, 0, 0, 0.85) 40%,
                    rgba(0, 0, 0, 0.6) 60%,
                    rgba(0, 0, 0, 0.3) 80%,
                    rgba(0, 0, 0, 0.1) 100%);
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 0.75rem 1rem 2rem;
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Use clamp() for responsive scaling with sensible min/max so large TVs don't grow fonts unbounded */
        .hero-title {
            font-size: clamp(1.1rem, calc(1.1rem + 2vw), 3rem);
            font-weight: 800;
            color: white;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 0.25rem;
            line-height: 1.2;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .hero-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.375rem;
            font-size: 0.7rem;
        }

        .hero-rating {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: #fbbf24;
            font-weight: 600;
        }

        .hero-overview {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.75rem;
            line-height: 1.3;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8);
            max-width: 100%;
            word-wrap: break-word;
        }

        .hero-buttons {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
        }

        .hero-btn {
            padding: 0.3rem 0.65rem;
            border-radius: 0.25rem;
            font-weight: 600;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
        }

        .hero-btn-play {
            background: white;
            color: black;
        }

        .hero-btn-play:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        .hero-btn-info {
            background: rgba(109, 109, 110, 0.7);
            color: white;
        }

        .hero-btn-info:hover {
            background: rgba(109, 109, 110, 0.9);
            transform: scale(1.05);
        }

        @media (min-width: 640px) {

            /* hero-title will scale via clamp() defined above; keep hero overview readable but bounded */
            .hero-overview {
                font-size: clamp(0.95rem, calc(0.75rem + 0.6vw), 1.1rem);
                -webkit-line-clamp: 4;
                line-clamp: 4;
            }

            .hero-content {
                padding: 2rem 2rem 6rem;
            }

            .hero-carousel {
                display: none !important;
            }
        }

        @media (max-width: 639px) {
            .hero-carousel {
                display: block !important;
            }
        }
    </style>
    <style>
        .horizontal-scroll {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            /* Use 'auto' here - we implement smooth mouse-wheel scrolling via JS to avoid
               jank caused by overlapping native smooth animations (particularly on Chrome). */
            scroll-behavior: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 0 1rem;
            overscroll-behavior-x: contain;
        }

        .horizontal-scroll::-webkit-scrollbar {
            display: none;
        }

        .scroll-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid transparent;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            opacity: 0.7;
        }

        .scroll-arrow:hover {
            opacity: 1;
            background: transparent;
            border-color: #3b82f6;
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .scroll-arrow:active {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .scroll-arrow.left {
            left: -60px;
        }

        .scroll-arrow.right {
            right: -60px;
        }

        .scroll-container {
            position: relative;
            margin: 0 -1rem;
        }

        .card-fixed {
            flex: 0 0 140px;
            min-width: 140px;
        }

        @media (min-width: 640px) {
            .card-fixed {
                flex: 0 0 200px;
                min-width: 200px;
            }
        }

        @media (min-width: 768px) {
            .card-fixed {
                flex: 0 0 220px;
                min-width: 220px;
            }
        }

        @media (min-width: 1024px) {
            .card-fixed {
                flex: 0 0 240px;
                min-width: 240px;
            }
        }

        /* Modal and Fullscreen Player Styles */
        [x-cloak] {
            display: none !important;
        }

        /* Smooth scrollbar for modal */
        .overflow-y-auto::-webkit-scrollbar {
            width: 8px;
        }

        .overflow-y-auto::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .overflow-y-auto::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .overflow-y-auto::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
    <style>
        /* Hide native vertical scrollbar when running as an installed PWA (standalone/fullscreen).
         Keep content scrollable (mouse wheel/keyboard/touch) but remove the visible scrollbar. */
        @media (display-mode: standalone),
        (display-mode: fullscreen) {

            html,
            body {
                scrollbar-width: none;
                /* Firefox */
                -ms-overflow-style: none;
                /* IE 10+ */
            }

            html::-webkit-scrollbar,
            body::-webkit-scrollbar {
                width: 0px;
                height: 0px;
                background: transparent;
            }
        }
    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAR3FWHBpaYsaiE-zGuMAX01ghQzkkN-6Y",
            authDomain: "spicyspicy-78ec1.firebaseapp.com",
            databaseURL: "https://spicyspicy-78ec1-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "spicyspicy-78ec1",
            storageBucket: "spicyspicy-78ec1.firebasestorage.app",
            messagingSenderId: "477298568930",
            appId: "1:477298568930:web:bc692a6c0bf90f8d27b8bb"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
    </script>
</head>

<body class="bg-amoled min-h-screen text-white" x-data="searchApp()">

    <!-- Top Right Login/Username Button -->
    <div class="fixed top-4 right-4 z-50 hidden sm:block">
        <!-- Login Button (when not logged in) -->
        <button x-show="!currentUsername" @click="showLoginModal = true"
            class="backdrop-blur-md bg-white/10 hover:bg-white/20 border border-white/20 text-white px-4 py-2 rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg">
            Login
        </button>

        <!-- Username Button (when logged in) -->
        <div x-show="currentUsername" class="relative" x-data="{ showLogoutMenu: false }">
            <button @click="showLogoutMenu = !showLogoutMenu"
                class="backdrop-blur-md bg-white/10 hover:bg-white/20 border border-white/20 text-white px-4 py-2 rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
                <span x-text="currentUsername"></span>
            </button>

            <!-- Logout Dropdown -->
            <div x-show="showLogoutMenu" @click.away="showLogoutMenu = false" x-cloak
                x-transition:enter="transition ease-out duration-200" x-transition:enter-start="opacity-0 scale-95"
                x-transition:enter-end="opacity-100 scale-100" x-transition:leave="transition ease-in duration-150"
                x-transition:leave-start="opacity-100 scale-100" x-transition:leave-end="opacity-0 scale-95"
                class="absolute right-0 mt-2 w-48 backdrop-blur-md bg-white/10 border border-white/20 rounded-lg shadow-xl overflow-hidden">
                <button @click="logout(); showLogoutMenu = false"
                    class="w-full px-4 py-3 text-left hover:bg-white/20 transition-all duration-200 flex items-center gap-2 text-white font-bold">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                    Logout
                </button>
            </div>
        </div>
    </div>

    <!-- Username Login Modal -->
    <div x-show="showLoginModal" x-cloak
        class="fixed inset-0 z-[100] flex items-center justify-center backdrop-blur-sm bg-black/80"
        @click.self="showLoginModal = false" x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0">
        <div class="backdrop-blur-xl bg-white/10 border border-white/20 p-8 rounded-2xl shadow-2xl max-w-md w-full mx-4"
            x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 scale-95"
            x-transition:enter-end="opacity-100 scale-100" x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 scale-100" x-transition:leave-end="opacity-0 scale-95">
            <h2 class="text-2xl font-bold mb-2 text-center text-white">Welcome to Spicy</h2>
            <p class="text-gray-300 text-sm mb-6 text-center">Enter your username to sync across devices</p>
            <input type="text" x-model="usernameInput" @keyup.enter="login()" placeholder="Enter username"
                class="w-full px-4 py-3 bg-white/10 backdrop-blur-sm border border-white/20 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-white/40 focus:ring-2 focus:ring-white/20 transition-all mb-4">
            <button @click="login()"
                class="w-full bg-white/10 backdrop-blur-sm hover:bg-white/20 border border-white/20 text-white font-bold py-3 rounded-lg transition-all duration-200 hover:scale-105 shadow-lg">
                Continue
            </button>
            <p class="text-xs text-gray-400 mt-4 text-center">Your watchlist and progress will sync across all your
                devices</p>
        </div>
    </div>

    <!-- Hero Carousel (Mobile Only) -->
    <div x-show="showHeroCarousel && getHeroItems().length > 0" class="hero-carousel sm:hidden"
        x-init="startHeroCarousel()" @touchstart="handleHeroTouchStart($event)" @touchmove="handleHeroTouchMove($event)"
        @touchend="handleHeroTouchEnd($event)">
        <div class="hero-slides-container"
            :style="`transform: translateX(-${currentHeroSlide * 100}%); transition: ${heroTransition ? 'transform 0.3s ease-out' : 'none'}`">
            <template x-for="(item, index) in getHeroItems()" :key="'hero-' + index">
                <div class="hero-slide">
                    <!-- Poster/Backdrop only: trailer playback disabled on mobile to reduce data usage and improve performance -->
                    <div class="hero-backdrop"
                        :style="`background-image: url('https://image.tmdb.org/t/p/original${item.backdrop_path || item.poster_path}')`">
                    </div>
                    <div class="hero-gradient"></div>
                    <div class="hero-content">
                        <h1 class="hero-title" x-text="item.title || item.name"></h1>
                        <div class="hero-meta">
                            <span class="hero-rating">
                                ⭐ <span x-text="item.vote_average ? item.vote_average.toFixed(1) : 'N/A'"></span>
                            </span>
                            <span class="text-gray-300">•</span>
                            <span class="text-gray-300"
                                x-text="(item.release_date || item.first_air_date || '').substring(0, 4)"></span>
                        </div>
                        <p class="hero-overview" x-text="item.overview || 'No description available.'"></p>
                        <div class="hero-buttons">
                            <button @click.stop="playHeroContent(item)" class="hero-btn hero-btn-play">
                                <svg class="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20">
                                    <path
                                        d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
                                </svg>
                                Play
                            </button>
                            <button @click.stop="toggleWatchlist(item)" class="hero-btn hero-btn-info">
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        :d="isInWatchlist(item.id) ? 'M5 13l4 4L19 7' : 'M12 4v16m8-8H4'" />
                                </svg>
                                <span x-text="isInWatchlist(item.id) ? 'In List' : 'My List'"></span>
                            </button>
                            <!-- hero trailer control removed for mobile hero carousel -->
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <div class="container mx-auto px-4 pt-0 pb-16 sm:py-24 md:py-32 lg:py-48">
        <!-- Header - No buttons needed on home page -->
        <!-- Search Bar -->
        <div x-show="showSearchBar" class="hidden sm:flex justify-center mb-8 sm:mb-12 fade-in">
            <div class="search-container max-w-md sm:max-w-lg md:max-w-xl lg:max-w-2xl xl:max-w-3xl">
                <input type="text" x-model="searchQuery" @keyup.debounce.500ms="searchContent()"
                    @keyup.enter="searchContent()" placeholder="s e a r c h   c o n t e n t"
                    class="search-input tv-navigable-item" x-ref="searchInput">
            </div>
        </div>

        <!-- Loading State -->
        <div x-show="isLoading" class="flex justify-center mb-6 sm:mb-8">
            <div class="animate-spin rounded-full h-6 w-6 sm:h-8 sm:w-8 border-b-2 border-blue-400"></div>
        </div>

        <!-- Results -->
        <div x-show="results.length > 0 && !isLoading" class="max-w-7xl mx-auto">
            <h2 class="text-xl sm:text-2xl font-bold text-white mb-4 sm:mb-6">Search Results</h2>
            <div class="scroll-container">
                <div id="results-container" class="horizontal-scroll">
                    <template x-for="(item, index) in results" :key="'result-' + index">
                        <div class="card-fixed tv-navigable-item card-animate"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path"
                                        :alt="item.title || item.name" class="w-full h-full object-cover" loading="lazy"
                                        decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Watchlist -->
        <div x-show="showWatchlist && getFilteredWatchlist().length > 0"
            class="max-w-7xl mx-auto mt-4 sm:mt-6 fade-in fade-in-delay-1">
            <h2 class="text-xl sm:text-2xl font-bold text-white mb-4 sm:mb-6">My Watchlist</h2>
            <div class="scroll-container">
                <div id="watchlist-container" class="horizontal-scroll">
                    <template x-for="(item, index) in getFilteredWatchlist()"
                        :key="'watchlist-' + item.id + '-' + index">
                        <div class="card-fixed tv-navigable-item card-animate"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path" :alt="item.title"
                                        class="w-full h-full object-cover" loading="lazy" decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Continue Watching -->
        <div id="continue-watching-section" x-show="showContinueWatching && getFilteredContinueWatching().length > 0"
            class="max-w-7xl mx-auto mt-8 sm:mt-12 fade-in fade-in-delay-2">
            <h2 class="text-xl sm:text-2xl font-bold text-white mb-4 sm:mb-6">Continue Watching</h2>
            <div class="scroll-container">
                <div id="continue-watching-container" class="horizontal-scroll">
                    <template x-for="(item, index) in getFilteredContinueWatching()"
                        :key="'continue-' + item.id + '-' + index">
                        <div class="card-fixed tv-navigable-item card-animate-slide-left"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path" :alt="item.title"
                                        class="w-full h-full object-cover" loading="lazy" decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                    <div class="absolute top-2 right-2 flex space-x-2 z-20">
                                        <button @click.stop.prevent="removeFromContinueWatching(item.id)"
                                            class="bg-red-600 hover:bg-red-700 text-white p-1.5 sm:p-2 rounded-full transition-all z-20 relative cursor-pointer">
                                            <svg xmlns="http://www.w3.org/2000/svg"
                                                class="h-4 w-4 sm:h-5 sm:w-5 pointer-events-none" fill="none"
                                                viewBox="0 0 24 24" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Trending -->
        <div x-show="showTrending && (getFilteredTrending() || []).length > 0"
            class="hidden sm:block max-w-7xl mx-auto mt-8 sm:mt-12 fade-in fade-in-delay-4">
            <div class="flex items-center justify-between mb-4 sm:mb-6">
                <h2 class="text-xl sm:text-2xl font-bold text-white">Trending</h2>
                <div class="hidden sm:flex bg-amoled-light rounded-lg p-1 border border-amoled-border">
                    <button @click="trendingType = 'movie'"
                        :class="trendingType === 'movie' ? 'bg-white/20 text-white border-white/40' : 'text-gray-400 hover:text-white hover:bg-white/10'"
                        class="px-3 py-1 sm:px-4 sm:py-2 rounded-md text-sm font-medium transition-all backdrop-blur-md border border-transparent">
                        Movies
                    </button>
                    <button @click="trendingType = 'tv'"
                        :class="trendingType === 'tv' ? 'bg-white/20 text-white border-white/40' : 'text-gray-400 hover:text-white hover:bg-white/10'"
                        class="px-3 py-1 sm:px-4 sm:py-2 rounded-md text-sm font-medium transition-all backdrop-blur-md border border-transparent">
                        TV Shows
                    </button>
                </div>
            </div>
            <div class="scroll-container">
                <div id="trending-container" class="horizontal-scroll">
                    <template x-for="(item, index) in getFilteredTrending()" :key="'trend-' + index">
                        <div class="card-fixed tv-navigable-item card-animate-slide-right"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path"
                                        :alt="item.title || item.name" class="w-full h-full object-cover" loading="lazy"
                                        decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Popular (Unified for Mobile) -->
        <div x-show="showPopular && getFilteredPopular().length > 0"
            class="max-w-7xl mx-auto mt-8 sm:mt-12 fade-in fade-in-delay-4 sm:hidden">
            <div class="flex items-center justify-between mb-4 sm:mb-6">
                <h2 class="text-xl sm:text-2xl font-bold text-white">Popular</h2>
            </div>
            <div class="scroll-container">
                <div id="popular-container" class="horizontal-scroll">
                    <template x-for="(item, index) in getFilteredPopular()" :key="'popular-' + index">
                        <div class="card-fixed tv-navigable-item card-animate"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path"
                                        :alt="item.title || item.name" class="w-full h-full object-cover" loading="lazy"
                                        decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Animation Section -->
        <div x-show="showHindi && getFilteredHindi().length > 0"
            class="max-w-7xl mx-auto mt-8 sm:mt-12 fade-in fade-in-delay-5 sm:hidden">
            <div class="flex items-center justify-between mb-4 sm:mb-6">
                <h2 class="text-xl sm:text-2xl font-bold text-white">Animation</h2>
                <div class="hidden sm:flex bg-amoled-light rounded-lg p-1 border border-amoled-border">
                    <button @click="hindiType = 'movie'"
                        :class="hindiType === 'movie' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'"
                        class="px-3 py-1 sm:px-4 sm:py-2 rounded-md text-sm font-medium transition-all">
                        Movies
                    </button>
                    <button @click="hindiType = 'tv'"
                        :class="hindiType === 'tv' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'"
                        class="px-3 py-1 sm:px-4 sm:py-2 rounded-md text-sm font-medium transition-all">
                        TV Shows
                    </button>
                </div>
            </div>
            <div class="scroll-container">
                <div id="hindi-container" class="horizontal-scroll">
                    <template x-for="(item, index) in getFilteredHindi()" :key="'hindi-' + index">
                        <div class="card-fixed tv-navigable-item card-animate-slide-right"
                            :class="'card-delay-' + ((index % 20) + 1)">
                            <div class="card-hover bg-amoled-card rounded-lg overflow-hidden shadow-lg cursor-pointer border border-amoled-border"
                                @click="watchContent(item)">
                                <div class="aspect-[2/3] relative">
                                    <img :src="'https://image.tmdb.org/t/p/w300' + item.poster_path"
                                        :alt="item.title || item.name" class="w-full h-full object-cover" loading="lazy"
                                        decoding="async" @error="event => {
                                            event.target.src = 'https://via.placeholder.com/300x450?text=No+Image';
                                        }">
                                    <div
                                        class="card-overlay absolute inset-0 flex flex-col justify-end p-2 sm:p-3 md:p-4">
                                        <h3 class="text-sm md:text-lg font-semibold" x-text="item.title || item.name">
                                        </h3>
                                        <p class="text-gray-400 text-xs md:text-sm mt-1"
                                            x-text="'⭐ ' + (item.vote_average ? item.vote_average.toFixed(1) : 'N/A') + '/10'">
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Initial State -->
        <div x-show="!searchQuery" class="text-center py-8 sm:py-12">
        </div>
    </div>



    <!-- Search Overlay -->
    <div x-show="showSearch" class="search-overlay fixed inset-0 bg-amoled bg-opacity-95 z-50 p-4 flex flex-col"
        @click.self="toggleSearch()" x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0">
        <div class="relative mb-6 mt-4">
            <input type="text" x-model="searchQuery" @keyup.debounce.500ms="searchContent()"
                @keyup.enter="searchContent()" placeholder="Search for movies, TV shows..."
                class="tv-navigable-item w-full py-3 pl-4 pr-10 border-b-2 border-gray-600 bg-transparent text-white text-lg focus:outline-none focus:border-blue-500 transition-colors"
                x-ref="searchOverlayInput">
            <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
            </div>
        </div>

        <!-- Loading State -->
        <div x-show="isLoading" class="flex justify-center items-center flex-grow" @click.stop>
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-400"></div>
        </div>

        <!-- Results -->
        <div x-show="!isLoading && results.length > 0" class="flex-grow overflow-y-auto -mr-4 pr-4" @click.stop>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                <template x-for="(item, index) in results" :key="item.id">
                    <div @click="watchContent(item)" class="tv-navigable-item cursor-pointer group card-animate"
                        :class="'card-delay-' + ((index % 20) + 1)">
                        <div class="relative aspect-[2/3] bg-amoled-card rounded-lg overflow-hidden">
                            <img :src="item.poster_path ? 'https://image.tmdb.org/t/p/w300' + item.poster_path : 'https://via.placeholder.com/300x450?text=No+Image'"
                                :alt="item.title || item.name"
                                class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                                loading="lazy" decoding="async"
                                @error="event => { event.target.src = 'https://via.placeholder.com/300x450?text=No+Image'; }">
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                            <h3 class="absolute bottom-2 left-2 right-2 text-sm font-semibold text-white"
                                x-text="item.title || item.name"></h3>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- No Results -->
        <div x-show="!isLoading && searchQuery && results.length === 0"
            class="flex flex-col justify-center items-center flex-grow text-center text-gray-400" @click.stop>
            <svg class="w-12 h-12 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.467-.881-6.08-2.33" />
            </svg>
            <p>No results found for "<span x-text="searchQuery" class="font-semibold text-gray-300"></span>"</p>
        </div>
    </div>

    <!-- Content Modal Overlay -->
    <div x-show="showModal" class="fixed inset-0 z-50 overflow-y-auto" @click.self="closeModal()"
        @keydown.escape.window="closeModal()" x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0">

        <!-- Background Overlay -->
        <div class="fixed inset-0 bg-black/90 backdrop-blur-sm" @click="closeModal()"></div>

        <!-- Modal Content -->
        <div class="relative min-h-screen flex items-center justify-center p-4" @click.self="closeModal()">
            <div class="relative w-full max-w-md sm:max-w-4xl modal-content bg-amoled-card rounded-xl shadow-2xl overflow-hidden"
                x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 scale-95"
                x-transition:enter-end="opacity-100 scale-100" x-transition:leave="transition ease-in duration-200"
                x-transition:leave-start="opacity-100 scale-100" x-transition:leave-end="opacity-0 scale-95">

                <!-- Close Button -->
                <button @click="closeModal()"
                    class="tv-navigable-item absolute top-4 right-4 z-30 p-2 rounded-full bg-black/70 hover:bg-black/90 text-white transition-all duration-200 hover:scale-110">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>

                <!-- Content Info Section with Trailer Background -->
                <template x-if="selectedContent">
                    <div class="flex flex-col sm:relative sm:min-h-[500px] lg:min-h-[600px]">
                        <!-- Trailer Section - Top on Mobile, Background on Desktop -->
                        <div x-show="selectedTrailerUrl"
                            class="relative sm:absolute sm:inset-0 z-0 h-[250px] sm:h-auto">
                            <div class="absolute inset-0 overflow-hidden">
                                <!-- Poster Background (shown initially) -->
                                <div x-show="!isTrailerReady" class="absolute inset-0 bg-cover bg-center"
                                    :style="`background-image: url('https://image.tmdb.org/t/p/original${selectedContent?.backdrop_path || selectedContent?.poster_path}')`">
                                </div>

                                <!-- Trailer Iframe (shown when ready) -->
                                <iframe x-show="isTrailerReady"
                                    :src="selectedTrailerUrl ? selectedTrailerUrl + '&enablejsapi=1&autoplay=1&mute=1&controls=0&loop=1&playlist=' + selectedTrailerUrl.split('/embed/')[1]?.split('?')[0] : ''"
                                    allow="autoplay; encrypted-media"
                                    class="absolute top-1/2 left-1/2 w-[100vw] h-[100vh] -translate-x-1/2 -translate-y-1/2 pointer-events-none">
                                </iframe>
                            </div>
                            <div
                                class="absolute inset-0 bg-gradient-to-t from-black via-black/60 to-transparent sm:from-black sm:via-black/60 sm:to-transparent">
                            </div>
                        </div>

                        <!-- Content Details - Below Trailer on Mobile, Overlay on Desktop -->
                        <div
                            class="relative sm:absolute sm:bottom-0 sm:left-0 sm:right-0 z-10 p-4 sm:p-4 lg:p-6 bg-amoled sm:bg-transparent">
                            <div class="flex flex-col lg:flex-row gap-3 sm:gap-4 max-w-4xl">
                                <!-- Poster -->
                                <div class="flex-shrink-0 hidden lg:block">
                                    <img :src="selectedContent?.poster_path ? 'https://image.tmdb.org/t/p/w300' + selectedContent.poster_path : 'https://via.placeholder.com/300x450?text=No+Image'"
                                        :alt="selectedContent?.title || selectedContent?.name"
                                        class="w-32 xl:w-36 rounded-lg shadow-2xl">
                                </div>

                                <!-- Details -->
                                <div class="flex-1 min-w-0">
                                    <h2 class="text-xl sm:text-2xl lg:text-3xl font-bold text-white mb-2 line-clamp-2"
                                        x-text="selectedContent?.title || selectedContent?.name"></h2>

                                    <div
                                        class="flex flex-wrap items-center gap-2 mb-2 text-xs sm:text-xs text-gray-100">
                                        <span x-show="selectedContent?.release_date || selectedContent?.first_air_date"
                                            class="flex items-center">
                                            <svg class="w-3.5 h-3.5 mr-1" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z">
                                                </path>
                                            </svg>
                                            <span
                                                x-text="new Date(selectedContent?.release_date || selectedContent?.first_air_date).getFullYear()"></span>
                                        </span>

                                        <span x-show="selectedContent?.vote_average" class="flex items-center">
                                            <svg class="w-3.5 h-3.5 mr-1 text-yellow-400" fill="currentColor"
                                                viewBox="0 0 24 24">
                                                <path
                                                    d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z">
                                                </path>
                                            </svg>
                                            <span x-text="selectedContent?.vote_average?.toFixed(1) + '/10'"></span>
                                        </span>

                                        <span x-show="selectedContent?.runtime" class="flex items-center">
                                            <svg class="w-3.5 h-3.5 mr-1" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                            </svg>
                                            <span x-text="selectedContent?.runtime + ' min'"></span>
                                        </span>

                                        <span x-show="selectedIsShow && selectedContent?.number_of_seasons"
                                            class="flex items-center">
                                            <svg class="w-3.5 h-3.5 mr-1" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10">
                                                </path>
                                            </svg>
                                            <span
                                                x-text="selectedContent?.number_of_seasons + ' Season' + (selectedContent?.number_of_seasons > 1 ? 's' : '')"></span>
                                        </span>
                                    </div>

                                    <div x-show="selectedContent?.genres && selectedContent?.genres.length > 0"
                                        class="flex flex-wrap gap-1.5 mb-2 sm:mb-3">
                                        <template x-for="genre in (selectedContent?.genres || [])" :key="genre.id">
                                            <span
                                                class="px-2 py-0.5 sm:px-2.5 sm:py-1 bg-blue-600/40 text-blue-100 rounded-full text-xs font-medium backdrop-blur-md shadow-lg"
                                                x-text="genre.name"></span>
                                        </template>
                                    </div>

                                    <p x-show="selectedContent?.overview"
                                        class="text-gray-50 text-xs sm:text-sm lg:text-sm leading-relaxed mb-3 sm:mb-4 line-clamp-2 lg:line-clamp-3"
                                        x-text="selectedContent?.overview">
                                    </p>

                                    <!-- Action Buttons -->
                                    <div class="flex flex-wrap gap-2">
                                        <button @click="playFullscreen()"
                                            class="tv-navigable-item flex items-center gap-1.5 px-4 py-2 sm:px-5 sm:py-2.5 bg-white/10 hover:bg-white/20 backdrop-blur-md border border-white/20 text-white rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg text-xs sm:text-sm">
                                            <span>Play</span>
                                        </button>

                                        <button @click.stop="toggleWatchlist(selectedContent)"
                                            class="tv-navigable-item flex items-center gap-1.5 px-4 py-2 sm:px-5 sm:py-2.5 backdrop-blur-md border rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg text-xs sm:text-sm"
                                            :class="isInWatchlist(selectedContent?.id) ? 'bg-white/20 hover:bg-white/30 border-white/40 text-white' : 'bg-white/10 hover:bg-white/20 border-white/20 text-white'">
                                            <span
                                                x-text="isInWatchlist(selectedContent?.id) ? 'In List' : 'My List'"></span>
                                        </button>

                                        <button @click="toggleModalTrailerMute()"
                                            class="tv-navigable-item flex items-center gap-1.5 px-4 py-2 sm:px-5 sm:py-2.5 bg-white/10 hover:bg-white/20 backdrop-blur-md border border-white/20 text-white rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg text-xs sm:text-sm"
                                            :title="isModalTrailerMuted ? 'Unmute Trailer' : 'Mute Trailer'">
                                            <svg x-show="isModalTrailerMuted" class="h-4 w-4 sm:h-5 sm:w-5 text-white"
                                                fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
                                            </svg>
                                            <svg x-show="!isModalTrailerMuted" class="h-4 w-4 sm:h-5 sm:w-5 text-white"
                                                fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                                            </svg>
                                        </button>

                                        <button x-show="selectedIsShow"
                                            @click="showEpisodeSelector = !showEpisodeSelector; updateModalNavigation()"
                                            class="tv-navigable-item flex items-center gap-1.5 px-4 py-2 sm:px-5 sm:py-2.5 bg-white/10 hover:bg-white/20 backdrop-blur-md border border-white/20 text-white rounded-lg font-bold transition-all duration-200 hover:scale-105 shadow-lg text-xs sm:text-sm">
                                            <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor"
                                                viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M4 6h16M4 12h16M4 18h16"></path>
                                            </svg>
                                            <span>Episodes</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                </template>

                <!-- Episode Selector for TV Shows -->
                <div x-show="selectedIsShow && showEpisodeSelector"
                    class="p-3 sm:p-4 bg-amoled border-t border-amoled-border max-h-[400px] sm:max-h-96 overflow-y-auto">
                    <h3 class="text-lg font-bold mb-3 text-white">Episodes</h3>

                    <!-- Season Selector -->
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Season</label>
                        <select x-model.number="selectedSeason" @change="loadModalEpisodes()"
                            class="w-full px-3 py-2 border border-amoled-border rounded-md bg-amoled-light text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <template x-for="season in selectedSeasons" :key="season">
                                <option :value="season" x-text="'Season ' + season"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Episodes Grid -->
                    <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3">
                        <template x-for="episode in selectedEpisodes" :key="episode.episode_number">
                            <div @click="selectedEpisode = episode.episode_number; playFullscreen()"
                                class="tv-navigable-item cursor-pointer bg-amoled-light rounded-lg p-3 hover:bg-amoled-card transition-colors border border-amoled-border hover:border-blue-500"
                                :class="selectedEpisode === episode.episode_number ? 'border-blue-500 bg-amoled-card' : ''">
                                <div class="aspect-video mb-2 bg-gray-600 rounded overflow-hidden">
                                    <img :src="episode.still_path ? 'https://image.tmdb.org/t/p/w300' + episode.still_path : 'https://via.placeholder.com/300x169?text=Ep+' + episode.episode_number"
                                        :alt="'Episode ' + episode.episode_number" class="w-full h-full object-cover">
                                </div>
                                <h4 class="font-medium text-sm text-white mb-1" x-text="'Ep ' + episode.episode_number">
                                </h4>
                                <p class="text-xs text-gray-400 line-clamp-2" x-text="episode.name"></p>
                            </div>
                        </template>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Fullscreen Player -->
    <div x-show="showFullscreenPlayer" x-cloak class="fixed inset-0 z-[100] bg-black"
        @keydown.escape.window="closeFullscreenPlayer()">

        <!-- Close Button -->
        <button @click="closeFullscreenPlayer()"
            class="absolute top-14 right-2.5 z-10 p-2 rounded-full bg-black/70 hover:bg-black/90 text-white transition-all duration-200 hover:scale-110">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>

        <!-- Player -->
        <div class="w-full h-full flex items-center justify-center">
            <iframe :src="fullscreenPlayerUrl" class="w-full h-full" allowfullscreen
                allow="autoplay *; encrypted-media *; fullscreen *; picture-in-picture *">
            </iframe>
        </div>

        <!-- Episode Navigation Controls (TV Shows Only) -->
        <div x-show="selectedIsShow && showFullscreenPlayer"
            class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-20 flex gap-2">
            <!-- Previous Episode Button -->
            <button @click="playPreviousEpisode()" x-show="canPlayPreviousEpisode()"
                class="px-3 py-1.5 rounded-md bg-black/70 hover:bg-black/90 text-white text-xs font-light transition-all duration-200 hover:scale-105 flex items-center gap-1">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Previous
            </button>

            <!-- Current Episode Info -->
            <div class="px-3 py-1.5 rounded-md bg-black/70 text-white text-xs font-light flex items-center">
                S<span x-text="selectedSeason"></span>E<span x-text="selectedEpisode"></span>
            </div>

            <!-- Next Episode Button -->
            <button @click="playNextEpisode()" x-show="canPlayNextEpisode()"
                class="px-3 py-1.5 rounded-md bg-black/70 hover:bg-black/90 text-white text-xs font-light transition-all duration-200 hover:scale-105 flex items-center gap-1">
                Next
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </button>
        </div>
    </div>

    <!-- Bottom Navigation (Mobile Only) -->
    <div
        class="fixed bottom-0 left-0 right-0 bg-amoled border-t border-amoled-border p-2 flex justify-around sm:hidden z-50">
        <a href="#"
            @click.prevent="contentType = 'movie'; trendingType = 'movie'; popularMoviesType = 'movie'; topRatedMoviesType = 'movie'; hindiType = 'movie'"
            class="tv-navigable-item flex flex-col items-center justify-center transition-colors w-full py-2 rounded-lg hover:bg-amoled-card"
            :class="contentType === 'movie' ? 'text-white' : 'text-gray-300 hover:text-white'">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z" />
            </svg>
            <span class="text-xs mt-1">Movies</span>
        </a>
        <a href="#"
            @click.prevent="contentType = 'tv'; trendingType = 'tv'; popularTVShowsType = 'tv'; topRatedTVShowsType = 'tv'; hindiType = 'tv'"
            class="tv-navigable-item flex flex-col items-center justify-center transition-colors w-full py-2 rounded-lg hover:bg-amoled-card"
            :class="contentType === 'tv' ? 'text-white' : 'text-gray-300 hover:text-white'">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
            <span class="text-xs mt-1">Series</span>
        </a>
        <a href="#" @click.prevent="toggleSearch()"
            class="tv-navigable-item flex flex-col items-center justify-center text-gray-300 hover:text-white transition-colors w-full py-2 rounded-lg hover:bg-amoled-card">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <span class="text-xs mt-1">Search</span>
        </a>

        <!-- Mobile Account Button -->
        <div class="relative w-full" x-data="{ showMobileAccountMenu: false }">
            <!-- Login Icon (when not logged in) -->
            <a href="#" @click.prevent="showLoginModal = true" x-show="!currentUsername"
                class="tv-navigable-item flex flex-col items-center justify-center text-gray-300 hover:text-white transition-colors w-full py-2 rounded-lg hover:bg-amoled-card">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
                <span class="text-xs mt-1">Login</span>
            </a>

            <!-- Account Icon (when logged in) -->
            <a href="#" @click.prevent="showMobileAccountMenu = !showMobileAccountMenu" x-show="currentUsername"
                class="tv-navigable-item flex flex-col items-center justify-center transition-colors w-full py-2 rounded-lg hover:bg-amoled-card"
                :class="showMobileAccountMenu ? 'text-white' : 'text-gray-300 hover:text-white'">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
                <span class="text-xs mt-1">Account</span>
            </a>

            <!-- Mobile Account Dropdown -->
            <div x-show="showMobileAccountMenu && currentUsername" @click.away="showMobileAccountMenu = false" x-cloak
                x-transition:enter="transition ease-out duration-200" x-transition:enter-start="opacity-0 translate-y-2"
                x-transition:enter-end="opacity-100 translate-y-0" x-transition:leave="transition ease-in duration-150"
                x-transition:leave-start="opacity-100 translate-y-0" x-transition:leave-end="opacity-0 translate-y-2"
                class="absolute bottom-full right-0 mb-2 w-48 backdrop-blur-md bg-white/10 border border-white/20 rounded-lg shadow-xl overflow-hidden">
                <div class="px-4 py-3 border-b border-white/10">
                    <p class="text-xs text-gray-400">Signed in as</p>
                    <p class="text-sm font-bold text-white truncate" x-text="currentUsername"></p>
                </div>
                <button @click="logout(); showMobileAccountMenu = false"
                    class="w-full px-4 py-3 text-left hover:bg-white/20 transition-all duration-200 flex items-center gap-2 text-white font-bold">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                    </svg>
                    Logout
                </button>
            </div>
        </div>
    </div>
    <script>
        function searchApp() {
            return {
                searchQuery: '',
                results: [],
                isLoading: false,
                watchlist: [],
                continueWatching: [],
                currentUsername: localStorage.getItem('spicy_username') || '',
                usernameInput: '',
                showLoginModal: false,
                firebaseListeners: [],
                trending: [],
                trendingType: 'movie', // 'movie' or 'tv'
                popularMovies: [],
                popularMoviesType: 'movie', // 'movie' or 'tv'
                topRatedMovies: [],
                topRatedMoviesType: 'movie', // 'movie' or 'tv'
                popularTVShows: [],
                popularTVShowsType: 'tv', // 'movie' or 'tv'
                topRatedTVShows: [],
                topRatedTVShowsType: 'tv', // 'movie' or 'tv'
                hindiMovies: [],
                hindiTVShows: [],
                hindiType: 'movie', // 'movie' or 'tv' for Hindi section
                contentType: 'movie', // 'movie' or 'tv' for mobile content filtering
                defaultSource: 'primewire', // Default source (PrimeWire)
                apiKey: '1070730380f5fee0d87cf0382670b255',
                showSearchBar: false,
                showWatchlist: false,
                showContinueWatching: false,
                showTrending: false,
                showPopular: false,
                showPopularMovies: false,
                showTopRatedMovies: false,
                showPopularTVShows: false,
                showTopRatedTVShows: false,
                showHindi: false,
                showSearch: false,
                showHeroCarousel: false,
                currentHeroSlide: 1, // Start at 1 because 0 is the duplicate last slide
                heroCarouselInterval: null,
                heroTouchStartX: 0,
                heroTouchEndX: 0,
                heroTransition: true, // Control transition animation
                // heroTrailers removed - hero carousel will show poster/backdrop only on mobile
                // Navigation properties
                currentSection: 0,
                currentItem: 0,
                sections: [
                    'search',
                    'watchlist',
                    'continue-watching',
                    'trending',
                    'popular-movies',
                    'popular-tv-shows',
                    'hindi',
                    'top-rated-movies',
                    'top-rated-tv-shows',
                    'bottom-navigation'
                ],
                // Modal navigation properties
                isModalNavigation: false,
                modalCurrentItem: 0,
                modalItems: [], // Will be populated when modal opens
                // Modal properties
                showModal: false,
                selectedContent: null,
                selectedContentId: null,
                selectedContentType: null,
                selectedIsShow: false,
                selectedTrailerUrl: '',
                isModalTrailerMuted: true,
                isHeroTrailerMuted: true,
                selectedSeason: 1,
                selectedEpisode: 1,
                selectedSeasons: [],
                selectedEpisodes: [],
                showEpisodeSelector: false,
                showFullscreenPlayer: false,
                fullscreenPlayerUrl: '',
                isTrailerReady: false, // Track if modal trailer is ready to play

                isMobileDevice() {
                    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                        (window.innerWidth <= 768);
                },

                init() {
                    // Initialize Firebase sync if user is logged in
                    if (this.currentUsername) {
                        this.initFirebaseSync();
                    } else {
                        // Only load from localStorage if not logged in (Firebase will handle it if logged in)
                        this.loadWatchlist();
                        this.loadContinueWatching();
                    }

                    this.loadDefaultSource();
                    this.loadTrending();
                    this.loadPopularMovies();
                    this.loadTopRatedMovies();
                    this.loadPopularTVShows();
                    this.loadTopRatedTVShows();
                    this.loadHindiMovies();
                    this.loadHindiTVShows();

                    // Listen for updates from watch.html via storage events (much more efficient than polling)
                    window.addEventListener('storage', (e) => {
                        if (e.key === 'streamSearch_continueWatching_update') {
                            this.checkForContinueWatchingUpdates();
                        }
                    });

                    // Refresh trending content every 30 minutes
                    setInterval(() => {
                        this.loadTrending();
                    }, 30 * 60 * 1000); // 30 minutes

                    // Progressive loading with fast delays
                    setTimeout(() => { this.showSearchBar = true; }, 50);
                    setTimeout(() => { this.showHeroCarousel = true; }, 100);
                    setTimeout(() => { this.showWatchlist = true; }, 150);
                    setTimeout(() => { this.showContinueWatching = true; }, 200);
                    setTimeout(() => { this.showTrending = true; }, 300);
                    setTimeout(() => { this.showPopular = true; }, 400);
                    setTimeout(() => { this.showHindi = true; }, 600);
                    setTimeout(() => { this.showTopRatedMovies = true; }, 700);
                    setTimeout(() => { this.showTopRatedTVShows = true; }, 800);

                    // Add mouse wheel support for horizontal scrolling
                    this.initMouseWheelScrolling();

                    // Always enable keyboard navigation
                    this.initKeyboardNavigation();

                    // Add double tap detection for mobile content switching
                    this.initSwipeDetection();

                    // Ensure navigation starts on a valid section
                    setTimeout(() => {
                        this.ensureValidNavigation();
                    }, 1500); // Wait for content to load

                    // Remove transition class after page loads
                    document.body.classList.remove('page-transition-out');
                },

                // Page transition navigation
                navigateWithTransition(url) {
                    // Close search overlay before navigating
                    this.showSearch = false;
                    this.searchQuery = '';
                    this.results = [];

                    document.body.classList.add('page-transition-out');
                    setTimeout(() => {
                        window.location.href = url;
                    }, 300); // Match transition duration
                },                // Hero Carousel Functions
                getHeroItems() {
                    // Use trending content filtered by content type (10 items)
                    const trendingItems = this.trending && this.trending.length > 0
                        ? this.trending.filter(item => item.media_type === this.contentType)
                        : [];
                    const items = trendingItems.slice(0, 10); // Get first 10 filtered trending items

                    // Create infinite loop by adding last item at start and first item at end
                    if (items.length > 0) {
                        return [items[items.length - 1], ...items, items[0]];
                    }
                    return items;
                },

                async loadHeroTrailers() {
                    // Disabled: hero trailer fetching is turned off for mobile hero carousel (poster-only)
                    return;
                },

                async loadCurrentHeroTrailer() {
                    // Disabled: hero trailer fetching is turned off for mobile hero carousel (poster-only)
                    return;
                },

                startHeroCarousel() {
                    // Auto-rotate every 15 seconds
                    this.heroCarouselInterval = setInterval(() => {
                        this.nextHeroSlide();
                    }, 15000);
                },

                stopHeroCarousel() {
                    if (this.heroCarouselInterval) {
                        clearInterval(this.heroCarouselInterval);
                        this.heroCarouselInterval = null;
                    }
                },

                nextHeroSlide() {
                    const items = this.getHeroItems();
                    if (items.length === 0) return;

                    // Mute the current trailer and reset state before transitioning
                    this.muteHeroTrailer();
                    this.isHeroTrailerMuted = true; // Reset mute state for new slide

                    const realLength = items.length - 2; // Subtract the 2 clones

                    this.heroTransition = true;
                    this.currentHeroSlide++;

                    // After transitioning to the clone at the end, snap back to real first slide
                    if (this.currentHeroSlide > realLength) {
                        setTimeout(() => {
                            this.heroTransition = false;
                            this.currentHeroSlide = 1; // Jump to real first slide (index 1)

                            // Re-enable transition after a brief moment
                            setTimeout(() => {
                                this.heroTransition = true;
                            }, 50);
                        }, 300);
                    }

                    // Loading of hero trailers disabled for mobile hero carousel (poster only)
                },

                prevHeroSlide() {
                    const items = this.getHeroItems();
                    if (items.length === 0) return;

                    // Mute the current trailer and reset state before transitioning
                    this.muteHeroTrailer();
                    this.isHeroTrailerMuted = true; // Reset mute state for new slide

                    const realLength = items.length - 2; // Subtract the 2 clones

                    this.heroTransition = true;
                    this.currentHeroSlide--;

                    // After transitioning to the clone at the start, snap back to real last slide
                    if (this.currentHeroSlide < 1) {
                        setTimeout(() => {
                            this.heroTransition = false;
                            this.currentHeroSlide = realLength; // Jump to real last slide

                            // Re-enable transition after a brief moment
                            setTimeout(() => {
                                this.heroTransition = true;
                            }, 50);
                        }, 300);
                    }

                    // Loading of hero trailers disabled for mobile hero carousel (poster only)
                }, goToHeroSlide(index) {
                    this.currentHeroSlide = index;
                    // Reset auto-rotation timer
                    this.stopHeroCarousel();
                    this.startHeroCarousel();
                },

                handleHeroTouchStart(e) {
                    this.heroTouchStartX = e.touches[0].clientX;
                    this.heroTouchEndX = e.touches[0].clientX; // Initialize to same position
                    this.stopHeroCarousel(); // Stop auto-rotation while swiping
                },

                handleHeroTouchMove(e) {
                    this.heroTouchEndX = e.touches[0].clientX;
                },

                handleHeroTouchEnd(e) {
                    const swipeThreshold = 50; // Minimum swipe distance in pixels
                    const diff = this.heroTouchStartX - this.heroTouchEndX;

                    // Only navigate if the swipe distance exceeds the threshold
                    if (Math.abs(diff) > swipeThreshold) {
                        if (diff > 0) {
                            // Swiped left - go to next slide
                            this.nextHeroSlide();
                        } else {
                            // Swiped right - go to previous slide
                            this.prevHeroSlide();
                        }
                    }
                    // If diff is less than threshold, it's a tap/click - do nothing

                    // Reset touch positions
                    this.heroTouchStartX = 0;
                    this.heroTouchEndX = 0;

                    // Restart auto-rotation after interaction
                    this.startHeroCarousel();
                },

                // Firebase Authentication & Sync Methods
                login() {
                    if (!this.usernameInput.trim()) {
                        alert('Please enter a username');
                        return;
                    }
                    this.currentUsername = this.usernameInput.trim();
                    localStorage.setItem('spicy_username', this.currentUsername);
                    this.showLoginModal = false;
                    this.initFirebaseSync();
                },

                logout() {
                    if (confirm('Are you sure you want to logout? Your data is synced to the cloud.')) {
                        this.currentUsername = '';
                        localStorage.removeItem('spicy_username');
                        // Remove Firebase listeners
                        this.firebaseListeners.forEach(listener => listener());
                        this.firebaseListeners = [];
                        location.reload();
                    }
                },

                initFirebaseSync() {
                    if (!this.currentUsername) return;

                    const userRef = database.ref(`users/${this.currentUsername}`);

                    // First, load existing local data
                    const localWatchlist = localStorage.getItem('streamSearch_watchlist');
                    const localContinueWatching = localStorage.getItem('streamSearch_continueWatching');

                    // Check if Firebase has data first
                    userRef.once('value', (snapshot) => {
                        const firebaseData = snapshot.val();

                        if (firebaseData) {
                            // Firebase has data - use it
                            if (firebaseData.watchlist) {
                                this.watchlist = firebaseData.watchlist;
                                localStorage.setItem('streamSearch_watchlist', JSON.stringify(firebaseData.watchlist));
                            } else if (localWatchlist) {
                                // Firebase empty but local has data - upload local
                                const parsed = JSON.parse(localWatchlist);
                                if (parsed.length > 0) {
                                    this.watchlist = parsed;
                                    userRef.child('watchlist').set(parsed);
                                }
                            }

                            if (firebaseData.continueWatching) {
                                this.continueWatching = firebaseData.continueWatching;
                                localStorage.setItem('streamSearch_continueWatching', JSON.stringify(firebaseData.continueWatching));
                            } else if (localContinueWatching) {
                                // Firebase empty but local has data - upload local
                                const parsed = JSON.parse(localContinueWatching);
                                if (parsed.length > 0) {
                                    this.continueWatching = parsed;
                                    userRef.child('continueWatching').set(parsed);
                                }
                            }
                        } else {
                            // No Firebase data - upload local if available
                            if (localWatchlist) {
                                const parsed = JSON.parse(localWatchlist);
                                if (parsed.length > 0) {
                                    this.watchlist = parsed;
                                    userRef.child('watchlist').set(parsed);
                                }
                            }

                            if (localContinueWatching) {
                                const parsed = JSON.parse(localContinueWatching);
                                if (parsed.length > 0) {
                                    this.continueWatching = parsed;
                                    userRef.child('continueWatching').set(parsed);
                                }
                            }
                        }
                    });

                    // Set up real-time listeners for live updates
                    const watchlistListener = userRef.child('watchlist').on('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            this.watchlist = data;
                            localStorage.setItem('streamSearch_watchlist', JSON.stringify(data));
                        }
                    });

                    const continueWatchingListener = userRef.child('continueWatching').on('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            this.continueWatching = data;
                            localStorage.setItem('streamSearch_continueWatching', JSON.stringify(data));
                        }
                    });

                    this.firebaseListeners.push(
                        () => userRef.child('watchlist').off('value', watchlistListener),
                        () => userRef.child('continueWatching').off('value', continueWatchingListener)
                    );
                },

                loadWatchlist() {
                    const saved = localStorage.getItem('streamSearch_watchlist');
                    if (saved) {
                        this.watchlist = JSON.parse(saved);
                    }
                },

                saveWatchlist() {
                    localStorage.setItem('streamSearch_watchlist', JSON.stringify(this.watchlist));

                    // Sync to Firebase if logged in
                    if (this.currentUsername) {
                        database.ref(`users/${this.currentUsername}/watchlist`).set(this.watchlist);
                    }
                },

                loadContinueWatching() {
                    const saved = localStorage.getItem('streamSearch_continueWatching');
                    if (saved) {
                        this.continueWatching = JSON.parse(saved);
                    }
                },

                saveContinueWatching() {
                    localStorage.setItem('streamSearch_continueWatching', JSON.stringify(this.continueWatching));

                    // Sync to Firebase if logged in
                    if (this.currentUsername) {
                        database.ref(`users/${this.currentUsername}/continueWatching`).set(this.continueWatching);
                    }
                },

                addToContinueWatching(item) {
                    // Remove if already exists
                    this.continueWatching = this.continueWatching.filter(cw => cw.id !== item.id);

                    // Prepare the continue watching item
                    const continueWatchingItem = {
                        id: item.id,
                        title: item.title || item.name,
                        media_type: item.media_type,
                        poster_path: item.poster_path,
                        release_date: item.release_date || item.first_air_date,
                        vote_average: item.vote_average,
                        overview: item.overview,
                        added_at: new Date().toISOString()
                    };

                    // For TV shows, store the last watched season and episode
                    if (item.media_type === 'tv') {
                        continueWatchingItem.last_season = item.last_season || 1;
                        continueWatchingItem.last_episode = item.last_episode || 1;
                    }

                    // Add to beginning (most recent)
                    this.continueWatching.unshift(continueWatchingItem);

                    // Keep only last 20 items
                    if (this.continueWatching.length > 20) {
                        this.continueWatching = this.continueWatching.slice(0, 20);
                    }

                    this.saveContinueWatching();
                },

                removeFromContinueWatching(itemId) {
                    this.continueWatching = this.continueWatching.filter(item => item.id !== itemId);
                    this.saveContinueWatching();
                },

                checkForContinueWatchingUpdates() {
                    const lastUpdate = localStorage.getItem('streamSearch_continueWatching_update');
                    if (lastUpdate) {
                        const updateData = JSON.parse(lastUpdate);
                        this.addToContinueWatching(updateData);
                        localStorage.removeItem('streamSearch_continueWatching_update');
                    }
                },

                loadDefaultSource() {
                    // Use PrimeWire as the default video source
                    this.defaultSource = 'primewire';
                },

                // Helper method to get URL from source template
                getSourceUrl(sourceId, type, params = {}) {
                    const source = window.SOURCES.find(s => s.id === sourceId);
                    if (!source) {
                        console.error(`Source ${sourceId} not found`);
                        return '';
                    }

                    let template = source[type];
                    if (!template) {
                        console.error(`Template for type ${type} not found in source ${sourceId}`);
                        return '';
                    }

                    // Replace placeholders in template
                    template = template.replace('{id}', params.id || '');
                    template = template.replace('{season}', params.season || '');
                    template = template.replace('{episode}', params.episode || '');

                    return template;
                },

                // Helper method to get URL using default source
                getDefaultSourceUrl(type, params = {}) {
                    return this.getSourceUrl(this.defaultSource, type, params);
                },

                async loadTrending() {
                    try {
                        // Load trending movies
                        const movieResponse = await fetch(`https://api.themoviedb.org/3/trending/movie/day?api_key=${this.apiKey}`);
                        const movieData = await movieResponse.json();
                        const movies = movieData.results.slice(0, 20).map(item => ({ ...item, media_type: 'movie' }));

                        // Load trending TV shows
                        const tvResponse = await fetch(`https://api.themoviedb.org/3/trending/tv/day?api_key=${this.apiKey}`);
                        const tvData = await tvResponse.json();
                        const tvShows = tvData.results.slice(0, 20).map(item => ({ ...item, media_type: 'tv' }));

                        // Combine and store
                        this.trending = [...movies, ...tvShows];

                        // Hero trailer loading disabled for mobile hero carousel — posters are used instead.
                    } catch (error) {
                        console.error('Error loading trending content:', error);
                        this.trending = [];
                    }
                }, async loadPopularMovies() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/movie/popular?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.popularMovies = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'movie' }));
                    } catch (error) {
                        console.error('Error loading popular movies:', error);
                        this.popularMovies = [];
                    }
                },

                async loadTopRatedMovies() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/movie/top_rated?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.topRatedMovies = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'movie' }));
                    } catch (error) {
                        console.error('Error loading top rated movies:', error);
                        this.topRatedMovies = [];
                    }
                },

                async loadPopularTVShows() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/tv/popular?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.popularTVShows = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'tv' }));
                    } catch (error) {
                        console.error('Error loading popular TV shows:', error);
                        this.popularTVShows = [];
                    }
                },

                async loadTopRatedTVShows() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/tv/top_rated?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.topRatedTVShows = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'tv' }));
                    } catch (error) {
                        console.error('Error loading top rated TV shows:', error);
                        this.topRatedTVShows = [];
                    }
                },

                async loadHindiMovies() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/discover/movie?api_key=${this.apiKey}&with_genres=16&sort_by=popularity.desc`);
                        const data = await response.json();
                        this.hindiMovies = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'movie' }));
                    } catch (error) {
                        console.error('Error loading Animation movies:', error);
                        this.hindiMovies = [];
                    }
                },

                async loadHindiTVShows() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/discover/tv?api_key=${this.apiKey}&with_genres=16&sort_by=popularity.desc`);
                        const data = await response.json();
                        this.hindiTVShows = data.results.slice(0, 20).map(item => ({ ...item, media_type: 'tv' }));
                    } catch (error) {
                        console.error('Error loading Animation TV shows:', error);
                        this.hindiTVShows = [];
                    }
                },

                getFilteredTrending() {
                    const type = this.isMobileDevice() ? this.contentType : this.trendingType;
                    return (this.trending || []).filter(item => item && item.media_type === type);
                },

                getFilteredPopular() {
                    // Combine both popular movies and TV shows, then filter by contentType on mobile
                    const combined = [...this.popularMovies, ...this.popularTVShows];
                    return combined.filter(item => item.media_type === this.contentType);
                },

                getFilteredPopularMovies() {
                    const type = this.isMobileDevice() ? this.contentType : this.popularMoviesType;
                    return this.popularMovies.filter(item => item.media_type === type);
                },

                getFilteredTopRatedMovies() {
                    const type = this.isMobileDevice() ? this.contentType : this.topRatedMoviesType;
                    return this.topRatedMovies.filter(item => item.media_type === type);
                },

                getFilteredPopularTVShows() {
                    const type = this.isMobileDevice() ? this.contentType : this.popularTVShowsType;
                    return this.popularTVShows.filter(item => item.media_type === type);
                },

                getFilteredTopRatedTVShows() {
                    const type = this.isMobileDevice() ? this.contentType : this.topRatedTVShowsType;
                    return this.topRatedTVShows.filter(item => item.media_type === type);
                },

                getFilteredHindi() {
                    const type = this.isMobileDevice() ? this.contentType : this.hindiType;
                    if (type === 'movie') {
                        return this.hindiMovies.filter(item => item.media_type === 'movie');
                    } else {
                        return this.hindiTVShows.filter(item => item.media_type === 'tv');
                    }
                },

                getFilteredWatchlist() {
                    // On mobile (width < 640px), filter by contentType for double-tap functionality
                    // On desktop, show all items (no filtering)
                    if (window.innerWidth < 640) {
                        return this.watchlist.filter(item => item.media_type === this.contentType);
                    }
                    return this.watchlist;
                },

                getFilteredContinueWatching() {
                    // On mobile (width < 640px), filter by contentType for double-tap functionality
                    // On desktop, show all items (no filtering)
                    if (window.innerWidth < 640) {
                        return this.continueWatching.filter(item => item.media_type === this.contentType);
                    }
                    return this.continueWatching;
                },

                scrollLeft(containerId) {
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.scrollBy({ left: -300, behavior: 'smooth' });
                    }
                },

                scrollRight(containerId) {
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.scrollBy({ left: 300, behavior: 'smooth' });
                    }
                },

                saveDefaultSource() {
                    try {
                        localStorage.setItem('streamSearch_defaultSource', this.defaultSource);
                    } catch (error) {
                        console.error('Error saving default source to localStorage:', error);
                    }
                },

                updateDefaultSource(sourceId) {
                    this.defaultSource = sourceId;
                    this.saveDefaultSource();
                },

                isInWatchlist(itemId) {
                    return this.watchlist.some(item => item.id === itemId);
                },

                toggleWatchlist(item) {
                    if (!item || !item.id) {
                        return;
                    }

                    const index = this.watchlist.findIndex(watchlistItem => watchlistItem.id === item.id);

                    if (index > -1) {
                        // Remove from watchlist
                        this.watchlist.splice(index, 1);
                    } else {
                        // Add to watchlist
                        // Determine media_type: use item.media_type if available, otherwise use selectedContentType, or fallback to checking dates
                        const mediaType = item.media_type || this.selectedContentType || (item.first_air_date ? 'tv' : 'movie');

                        this.watchlist.push({
                            id: item.id,
                            title: item.title || item.name,
                            media_type: mediaType,
                            poster_path: item.poster_path,
                            release_date: item.release_date || item.first_air_date,
                            vote_average: item.vote_average,
                            overview: item.overview
                        });
                    }
                    this.saveWatchlist();
                },

                async searchContent() {
                    if (!this.searchQuery.trim()) {
                        this.results = [];
                        return;
                    }

                    this.isLoading = true;

                    try {
                        const url = `https://api.themoviedb.org/3/search/multi?api_key=${this.apiKey}&query=${encodeURIComponent(this.searchQuery)}&include_adult=false`;
                        console.log('Searching:', url);

                        const response = await fetch(url);

                        if (!response.ok) {
                            throw new Error(`API request failed: ${response.status}`);
                        }

                        const data = await response.json();
                        console.log('API Response:', data);

                        // Filter out people and only show movies and TV shows
                        this.results = data.results.filter(item =>
                            item.media_type === 'movie' || item.media_type === 'tv'
                        );

                        console.log('Filtered results:', this.results);

                        // Update navigation if search results appeared
                        setTimeout(() => {
                            this.ensureValidNavigation();
                        }, 100);

                    } catch (error) {
                        console.error('Search error:', error);
                        this.results = [];
                    } finally {
                        this.isLoading = false;
                    }
                },

                async watchContent(item) {
                    // Close search overlay if open
                    if (this.showSearch) {
                        this.showSearch = false;
                        this.searchQuery = '';
                        this.results = [];
                    }

                    // Open modal instead of navigating to watch.html
                    this.selectedContentId = item.id;
                    this.selectedContentType = item.media_type === 'movie' ? 'movie' : 'tv';
                    this.selectedIsShow = this.selectedContentType === 'tv';
                    this.showModal = true;
                    this.showEpisodeSelector = false;

                    // Reset modal navigation
                    this.modalCurrentItem = 0;
                    this.modalItems = [];

                    // Update modal navigation after a short delay to ensure modal is rendered
                    setTimeout(() => {
                        this.updateModalNavigation();
                    }, 100);

                    // For TV shows from continue watching, restore the last watched season and episode
                    if (this.selectedIsShow && item.last_season && item.last_episode) {
                        // Ensure values are numbers for proper Alpine.js binding
                        this.selectedSeason = Number(item.last_season);
                        this.selectedEpisode = Number(item.last_episode);
                    } else {
                        this.selectedSeason = 1;
                        this.selectedEpisode = 1;
                    }

                    // Load content details
                    await this.loadModalContent();
                    await this.loadModalTrailer();

                    if (this.selectedIsShow) {
                        await this.loadModalEpisodes();
                    }

                    // Start trailer loading sequence - show poster first, then trailer
                    this.startTrailerSequence();
                },

                startTrailerSequence() {
                    // Reset trailer ready state
                    this.isTrailerReady = false;

                    // Show poster for 2 seconds, then switch to trailer
                    setTimeout(() => {
                        if (this.showModal && this.selectedTrailerUrl) {
                            this.isTrailerReady = true;
                        }
                    }, 2000);
                },

                async loadModalContent() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/${this.selectedContentType}/${this.selectedContentId}?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.selectedContent = data;

                        if (this.selectedIsShow) {
                            this.selectedSeasons = Array.from({ length: data.number_of_seasons }, (_, i) => i + 1);

                            // Ensure selectedSeason is within valid range
                            if (this.selectedSeason > data.number_of_seasons) {
                                this.selectedSeason = data.number_of_seasons;
                            }
                            if (this.selectedSeason < 1) {
                                this.selectedSeason = 1;
                            }
                        }
                    } catch (error) {
                        console.error('Error loading content:', error);
                    }
                },

                async loadModalTrailer() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/${this.selectedContentType}/${this.selectedContentId}/videos?api_key=${this.apiKey}`);
                        const data = await response.json();

                        const trailer = data.results?.find(video =>
                            video.type === 'Trailer' &&
                            video.site === 'YouTube' &&
                            video.official === true
                        ) || data.results?.find(video =>
                            video.type === 'Trailer' && video.site === 'YouTube'
                        );

                        if (trailer) {
                            this.selectedTrailerUrl = `https://www.youtube.com/embed/${trailer.key}?enablejsapi=1`;
                            this.isTrailerReady = false; // Reset trailer ready state when loading new trailer
                        } else {
                            this.selectedTrailerUrl = '';
                            this.isTrailerReady = false;
                        }
                    } catch (error) {
                        console.error('Error loading trailer:', error);
                        this.selectedTrailerUrl = '';
                        this.isTrailerReady = false;
                    }
                },

                async loadModalEpisodes() {
                    if (!this.selectedIsShow) return;

                    try {
                        // Ensure selectedSeason is a valid number
                        const seasonToLoad = parseInt(this.selectedSeason) || 1;

                        const response = await fetch(`https://api.themoviedb.org/3/tv/${this.selectedContentId}/season/${seasonToLoad}?api_key=${this.apiKey}`);
                        const data = await response.json();
                        this.selectedEpisodes = data.episodes || [];

                        // Re-affirm the selected season to ensure Alpine.js binding is correct
                        this.selectedSeason = seasonToLoad;

                        // Update modal navigation after episodes are loaded
                        this.updateModalNavigation();
                    } catch (error) {
                        console.error('Error loading episodes:', error);
                        this.selectedEpisodes = [];
                    }
                }, closeModal() {
                    // Stop the modal trailer before closing
                    const modalTrailerIframe = document.querySelector('.sm\\:absolute iframe');
                    if (modalTrailerIframe && modalTrailerIframe.contentWindow) {
                        try {
                            modalTrailerIframe.contentWindow.postMessage(
                                JSON.stringify({
                                    event: 'command',
                                    func: 'stopVideo',
                                    args: ''
                                }),
                                '*'
                            );
                        } catch (e) {
                            console.error('Failed to stop modal trailer:', e);
                        }
                    }

                    this.showModal = false;
                    this.selectedContent = null;
                    this.selectedTrailerUrl = '';
                    this.selectedEpisodes = [];
                    this.showEpisodeSelector = false;
                    this.isModalTrailerMuted = true;
                    this.isTrailerReady = false; // Reset trailer ready state

                    // Reset modal navigation
                    this.modalCurrentItem = 0;
                    this.modalItems = [];
                },

                toggleModalTrailerMute() {
                    this.isModalTrailerMuted = !this.isModalTrailerMuted;

                    // Select the modal trailer iframe - works for both mobile and desktop
                    const trailerIframe = document.querySelector('.sm\\:absolute iframe') || document.querySelector('.overflow-hidden iframe');
                    if (trailerIframe && trailerIframe.contentWindow) {
                        try {
                            const command = this.isModalTrailerMuted ? 'mute' : 'unMute';
                            trailerIframe.contentWindow.postMessage(
                                JSON.stringify({
                                    event: 'command',
                                    func: command,
                                    args: ''
                                }),
                                '*'
                            );
                        } catch (e) {
                            console.log('Failed to toggle mute:', e);
                        }
                    }
                },

                toggleHeroTrailerMute() {
                    this.isHeroTrailerMuted = !this.isHeroTrailerMuted;

                    // Only target the currently active slide's iframe
                    const heroSlides = document.querySelectorAll('.hero-slide');
                    const currentSlide = heroSlides[this.currentHeroSlide];

                    if (currentSlide) {
                        const iframe = currentSlide.querySelector('iframe');
                        if (iframe && iframe.contentWindow) {
                            try {
                                const command = this.isHeroTrailerMuted ? 'mute' : 'unMute';
                                iframe.contentWindow.postMessage(
                                    JSON.stringify({
                                        event: 'command',
                                        func: command,
                                        args: ''
                                    }),
                                    '*'
                                );
                            } catch (e) {
                                console.log('Failed to toggle hero mute:', e);
                            }
                        }
                    }
                },

                muteHeroTrailer() {
                    // Only mute if currently unmuted
                    if (!this.isHeroTrailerMuted) {
                        this.isHeroTrailerMuted = true;

                        // Only mute the currently active slide's iframe
                        const heroSlides = document.querySelectorAll('.hero-slide');
                        const currentSlide = heroSlides[this.currentHeroSlide];

                        if (currentSlide) {
                            const iframe = currentSlide.querySelector('iframe');
                            if (iframe && iframe.contentWindow) {
                                try {
                                    iframe.contentWindow.postMessage(
                                        JSON.stringify({
                                            event: 'command',
                                            func: 'mute',
                                            args: ''
                                        }),
                                        '*'
                                    );
                                } catch (e) {
                                    console.log('Failed to mute hero trailer:', e);
                                }
                            }
                        }
                    }
                },

                pauseHeroTrailer() {
                    // Pause all hero trailer iframes
                    const heroTrailerIframes = document.querySelectorAll('.hero-slide iframe');
                    heroTrailerIframes.forEach(iframe => {
                        if (iframe && iframe.contentWindow) {
                            try {
                                iframe.contentWindow.postMessage(
                                    JSON.stringify({
                                        event: 'command',
                                        func: 'pauseVideo',
                                        args: ''
                                    }),
                                    '*'
                                );
                            } catch (e) {
                                console.log('Failed to pause hero trailer:', e);
                            }
                        }
                    });
                },

                requestLandscape() {
                    // Request landscape orientation on mobile devices
                    if (this.isMobileDevice() && screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(err => {
                            console.log('Orientation lock not supported:', err);
                        });
                    }
                },

                unlockOrientation() {
                    // Unlock orientation when closing player
                    if (screen.orientation && screen.orientation.unlock) {
                        screen.orientation.unlock();
                    }
                },

                playHeroContent(item) {
                    // Directly play content in fullscreen from hero section
                    const contentId = item.id;
                    const isShow = item.media_type === 'tv' || item.first_air_date;
                    let url;

                    if (isShow) {
                        // For TV shows, play Season 1 Episode 1 using default source
                        url = this.getDefaultSourceUrl('tv', {
                            id: contentId,
                            season: 1,
                            episode: 1
                        });
                    } else {
                        // For movies
                        url = this.getDefaultSourceUrl('movie', {
                            id: contentId
                        });
                    }

                    // Stop hero carousel and pause trailer
                    this.stopHeroCarousel();
                    this.pauseHeroTrailer();

                    this.fullscreenPlayerUrl = url;
                    this.showFullscreenPlayer = true;

                    // Request landscape orientation on mobile
                    this.requestLandscape();

                    // Track as watched (for continue watching)
                    const continueWatchingData = {
                        id: contentId,
                        title: item.title || item.name,
                        media_type: isShow ? 'tv' : 'movie',
                        poster_path: item.poster_path,
                        release_date: item.release_date || item.first_air_date,
                        vote_average: item.vote_average,
                        overview: item.overview
                    };

                    // For TV shows, save season 1 episode 1
                    if (isShow) {
                        continueWatchingData.last_season = 1;
                        continueWatchingData.last_episode = 1;
                    }

                    this.addToContinueWatching(continueWatchingData);
                    localStorage.setItem('streamSearch_continueWatching_update', JSON.stringify(continueWatchingData));
                },

                playFullscreen() {
                    // Generate URL for player
                    let url;

                    if (this.selectedIsShow) {
                        url = this.getDefaultSourceUrl('tv', {
                            id: this.selectedContentId,
                            season: this.selectedSeason,
                            episode: this.selectedEpisode
                        });
                    } else {
                        url = this.getDefaultSourceUrl('movie', {
                            id: this.selectedContentId
                        });
                    }

                    // Stop the trailer before opening fullscreen player
                    this.stopModalTrailer();

                    this.fullscreenPlayerUrl = url;
                    this.showFullscreenPlayer = true;
                    this.showModal = false;

                    // Request landscape orientation on mobile
                    this.requestLandscape();

                    // Track as watched
                    this.trackWatched();
                },

                closeFullscreenPlayer() {
                    this.showFullscreenPlayer = false;
                    this.fullscreenPlayerUrl = '';
                    this.showModal = true;

                    // Unlock orientation
                    this.unlockOrientation();

                    // Reload the trailer when returning to modal
                    if (this.selectedContentId && this.selectedContentType) {
                        this.loadModalTrailer();
                        this.isTrailerReady = false; // Reset trailer ready state
                    }
                },

                canPlayNextEpisode() {
                    if (!this.selectedIsShow || !this.selectedEpisodes || this.selectedEpisodes.length === 0) {
                        return false;
                    }
                    // Check if there's a next episode in current season
                    const currentEpisodeIndex = this.selectedEpisodes.findIndex(ep => ep.episode_number === this.selectedEpisode);
                    if (currentEpisodeIndex < this.selectedEpisodes.length - 1) {
                        return true;
                    }
                    // Check if there's a next season
                    if (this.selectedSeasons && this.selectedSeason < this.selectedSeasons.length) {
                        return true;
                    }
                    return false;
                },

                canPlayPreviousEpisode() {
                    if (!this.selectedIsShow) {
                        return false;
                    }
                    // Check if there's a previous episode in current season
                    if (this.selectedEpisode > 1) {
                        return true;
                    }
                    // Check if there's a previous season
                    if (this.selectedSeason > 1) {
                        return true;
                    }
                    return false;
                },

                async playNextEpisode() {
                    if (!this.canPlayNextEpisode()) return;

                    const currentEpisodeIndex = this.selectedEpisodes.findIndex(ep => ep.episode_number === this.selectedEpisode);

                    // If there's a next episode in current season
                    if (currentEpisodeIndex < this.selectedEpisodes.length - 1) {
                        this.selectedEpisode = this.selectedEpisodes[currentEpisodeIndex + 1].episode_number;
                    } else {
                        // Move to next season's first episode
                        this.selectedSeason++;
                        await this.loadEpisodes();
                        this.selectedEpisode = 1;
                    }

                    // Update player URL
                    const url = this.getDefaultSourceUrl('tv', {
                        id: this.selectedContentId,
                        season: this.selectedSeason,
                        episode: this.selectedEpisode
                    });
                    this.fullscreenPlayerUrl = url;

                    // Update continue watching
                    this.updateContinueWatching();
                },

                async playPreviousEpisode() {
                    if (!this.canPlayPreviousEpisode()) return;

                    // If there's a previous episode in current season
                    if (this.selectedEpisode > 1) {
                        this.selectedEpisode--;
                    } else {
                        // Move to previous season's last episode
                        this.selectedSeason--;
                        await this.loadEpisodes();
                        // Set to last episode of the season
                        if (this.selectedEpisodes && this.selectedEpisodes.length > 0) {
                            this.selectedEpisode = this.selectedEpisodes[this.selectedEpisodes.length - 1].episode_number;
                        }
                    }

                    // Update player URL
                    const url = this.getDefaultSourceUrl('tv', {
                        id: this.selectedContentId,
                        season: this.selectedSeason,
                        episode: this.selectedEpisode
                    });
                    this.fullscreenPlayerUrl = url;

                    // Update continue watching
                    this.updateContinueWatching();
                },

                updateContinueWatching() {
                    if (!this.selectedIsShow) return;

                    const continueWatchingData = {
                        id: this.selectedContentId,
                        title: this.selectedContent.title || this.selectedContent.name,
                        media_type: 'tv',
                        poster_path: this.selectedContent.poster_path,
                        release_date: this.selectedContent.release_date || this.selectedContent.first_air_date,
                        vote_average: this.selectedContent.vote_average,
                        overview: this.selectedContent.overview,
                        last_season: this.selectedSeason,
                        last_episode: this.selectedEpisode
                    };

                    this.addToContinueWatching(continueWatchingData);
                    localStorage.setItem('streamSearch_continueWatching_update', JSON.stringify(continueWatchingData));
                },

                stopModalTrailer() {
                    // Send pause command to YouTube iframe
                    const trailerIframe = document.querySelector('.overflow-hidden iframe');
                    if (trailerIframe && trailerIframe.contentWindow) {
                        try {
                            trailerIframe.contentWindow.postMessage(
                                JSON.stringify({
                                    event: 'command',
                                    func: 'pauseVideo',
                                    args: ''
                                }),
                                '*'
                            );
                        } catch (e) {
                            console.log('Failed to pause trailer:', e);
                        }
                    }

                    // Clear the trailer URL to destroy the iframe
                    const currentTrailerUrl = this.selectedTrailerUrl;
                    this.selectedTrailerUrl = '';

                    // Store it temporarily to restore later if needed
                    this._pausedTrailerUrl = currentTrailerUrl;
                },

                trackWatched() {
                    const continueWatchingData = {
                        id: this.selectedContentId,
                        title: this.selectedContent.title || this.selectedContent.name,
                        media_type: this.selectedContentType,
                        poster_path: this.selectedContent.poster_path,
                        release_date: this.selectedContent.release_date || this.selectedContent.first_air_date,
                        vote_average: this.selectedContent.vote_average,
                        overview: this.selectedContent.overview
                    };

                    // For TV shows, save the current season and episode
                    if (this.selectedContentType === 'tv') {
                        continueWatchingData.last_season = this.selectedSeason;
                        continueWatchingData.last_episode = this.selectedEpisode;
                    }

                    // Add to continue watching on current page
                    this.addToContinueWatching(continueWatchingData);

                    // Also save to localStorage for cross-page updates
                    localStorage.setItem('streamSearch_continueWatching_update', JSON.stringify(continueWatchingData));
                },

                initMouseWheelScrolling() {
                    const scrollContainers = [
                        'results-container',
                        'watchlist-container',
                        'continue-watching-container',
                        'trending-container',
                        'popular-movies-container',
                        'top-rated-movies-container',
                        'popular-tv-container',
                        'top-rated-tv-container',
                        'hindi-container'
                    ];

                    scrollContainers.forEach(containerId => {
                        const container = document.getElementById(containerId);
                        if (container) {
                            container.addEventListener('wheel', (e) => {
                                this.handleMouseWheel(e, containerId);
                            }, { passive: false });
                        }
                    });
                },

                handleMouseWheel(e, containerId) {
                    const container = document.getElementById(containerId);
                    if (!container) return;

                    // If container doesn't overflow horizontally, don't intercept the wheel
                    if (container.scrollWidth <= container.clientWidth) return;

                    // Normalize deltaY (lines/pages to pixels)
                    let delta = e.deltaY || 0;
                    if (e.deltaMode === 1) { // DOM_DELTA_LINE
                        delta *= 16;
                    } else if (e.deltaMode === 2) { // DOM_DELTA_PAGE
                        delta *= window.innerHeight;
                    }

                    // Heuristic: small deltas usually come from trackpads - don't over-scale them.
                    const isTrackpad = Math.abs(delta) < 15;
                    // Slightly reduce scale for a slower feel: trackpads slightly under 1.0,
                    // mouse wheels reduced to 1.2 (was 1.8 previously).
                    const SCALE = isTrackpad ? 0.9 : 1.2;
                    delta = delta * SCALE;

                    // Prevent vertical page scrolling and convert it into horizontal scroll.
                    e.preventDefault();

                    // Maintain a per-container target position and animate to it using requestAnimationFrame.
                    this._wheelScrollStates = this._wheelScrollStates || {};
                    const state = this._wheelScrollStates[containerId] || { target: container.scrollLeft, raf: null };
                    state.target = Math.max(0, Math.min(state.target + delta, container.scrollWidth - container.clientWidth));
                    this._wheelScrollStates[containerId] = state;

                    // If an animation isn't already running, start one
                    if (!state.raf) {
                        const animate = () => {
                            // Smoothly approach the target with ease-out behaviour
                            const current = container.scrollLeft;
                            const diff = state.target - current;
                            // Reduce easing factor so animation progresses more slowly (gentler ease-out).
                            const step = diff * 0.18; // easing factor (was 0.27)

                            if (Math.abs(diff) > 0.5) {
                                container.scrollLeft = current + step;
                                state.raf = requestAnimationFrame(animate);
                            } else {
                                container.scrollLeft = state.target;
                                state.raf = null;
                            }
                        };
                        state.raf = requestAnimationFrame(animate);
                    }
                },

                initKeyboardNavigation() {
                    document.addEventListener('keydown', (e) => {
                        // Handle modal navigation first if modal is open
                        if (this.showModal) {
                            this.handleModalNavigation(e);
                            return;
                        }

                        // Handle search overlay navigation
                        if (this.showSearch) {
                            this.handleSearchOverlayNavigation(e);
                            return;
                        }

                        // Handle main page navigation
                        switch (e.key) {
                            case 'ArrowUp':
                                e.preventDefault();
                                this.navigateUp();
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                this.navigateDown();
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.navigateLeft();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.navigateRight();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                this.selectCurrentItem();
                                break;
                            case 'Escape':
                                e.preventDefault();
                                // Nothing to do on main page
                                break;
                        }
                    });
                },

                handleModalNavigation(e) {
                    switch (e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            this.navigateModalUp();
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.navigateModalDown();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.navigateModalLeft();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.navigateModalRight();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            this.selectModalItem();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.closeModal();
                            break;
                    }
                },

                handleSearchOverlayNavigation(e) {
                    switch (e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            // Navigate up in search results
                            if (this.currentItem > 0) {
                                this.currentItem--;
                                this.focusSearchResult();
                            }
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            // Navigate down in search results
                            if (this.currentItem < this.results.length - 1) {
                                this.currentItem++;
                                this.focusSearchResult();
                            }
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (this.results[this.currentItem]) {
                                this.watchContent(this.results[this.currentItem]);
                            }
                            break;
                        case 'Escape':
                            e.preventDefault();
                            this.toggleSearch();
                            break;
                    }
                },

                initSwipeDetection() {
                    if (!this.isMobileDevice()) return;

                    let lastTapTime = 0;
                    let tapTimeout = null;

                    document.addEventListener('touchend', (e) => {
                        const currentTime = new Date().getTime();
                        const tapInterval = currentTime - lastTapTime;

                        // Check if it's a double tap (within 300ms)
                        if (tapInterval < 300 && tapInterval > 0) {
                            // Clear any pending single tap
                            clearTimeout(tapTimeout);

                            // Check if tap was on an empty section
                            if (this.isDoubleTapOnEmptySection(e.target)) {
                                // Toggle between movie and tv
                                this.contentType = this.contentType === 'movie' ? 'tv' : 'movie';

                                // Reset hero carousel to first slide when content type changes
                                this.currentHeroSlide = 1; // Start at 1 (real first slide)
                                this.stopHeroCarousel();
                                this.startHeroCarousel();

                                // Trailer reloading disabled for mobile hero carousel (poster only)
                            } lastTapTime = 0; // Reset to prevent triple tap
                        } else {
                            lastTapTime = currentTime;
                        }
                    }, { passive: true });
                },

                isDoubleTapOnEmptySection(element) {
                    // Check if the double tap was on an empty area (not on cards, buttons, or interactive elements)
                    const interactiveSelectors = [
                        '.card-hover',
                        'button',
                        '.tv-navigable-item',
                        'a',
                        'input',
                        'select',
                        'textarea',
                        '[onclick]',
                        '[role="button"]'
                    ];

                    // Check if the element or any of its parents match interactive selectors
                    let currentElement = element;
                    while (currentElement && currentElement !== document.body) {
                        if (interactiveSelectors.some(selector => currentElement.matches && currentElement.matches(selector))) {
                            return false; // Tapped on an interactive element
                        }
                        currentElement = currentElement.parentElement;
                    }

                    return true; // Tapped on an empty section
                },

                navigateUp() {
                    let newSection = this.currentSection - 1;
                    while (newSection >= 0 && !this.isSectionVisible(this.sections[newSection])) {
                        newSection--;
                    }
                    if (newSection >= 0) {
                        this.currentSection = newSection;
                        this.currentItem = 0; // Reset to first item
                        console.log('Navigated up to section:', this.sections[this.currentSection], 'item:', this.currentItem);
                        this.focusCurrentItem();
                        this.scrollToCurrentSection();
                    } else {
                        // If no section above, wrap to last visible section
                        let lastVisible = this.sections.length - 1;
                        while (lastVisible > this.currentSection && !this.isSectionVisible(this.sections[lastVisible])) {
                            lastVisible--;
                        }
                        if (lastVisible !== this.currentSection && this.isSectionVisible(this.sections[lastVisible])) {
                            this.currentSection = lastVisible;
                            this.currentItem = 0; // Reset to first item
                            console.log('Wrapped up to section:', this.sections[this.currentSection], 'item:', this.currentItem);
                            this.focusCurrentItem();
                            this.scrollToCurrentSection();
                        }
                    }
                },

                navigateDown() {
                    let newSection = this.currentSection + 1;
                    while (newSection < this.sections.length && !this.isSectionVisible(this.sections[newSection])) {
                        newSection++;
                    }
                    if (newSection < this.sections.length) {
                        this.currentSection = newSection;
                        this.currentItem = 0; // Reset to first item
                        console.log('Navigated down to section:', this.sections[this.currentSection], 'item:', this.currentItem);
                        this.focusCurrentItem();
                        this.scrollToCurrentSection();
                    } else {
                        // If no section below, wrap to first visible section
                        let firstVisible = 0;
                        while (firstVisible < this.currentSection && !this.isSectionVisible(this.sections[firstVisible])) {
                            firstVisible++;
                        }
                        if (firstVisible !== this.currentSection && this.isSectionVisible(this.sections[firstVisible])) {
                            this.currentSection = firstVisible;
                            this.currentItem = 0; // Reset to first item
                            console.log('Wrapped down to section:', this.sections[this.currentSection], 'item:', this.currentItem);
                            this.focusCurrentItem();
                            this.scrollToCurrentSection();
                        }
                    }
                },

                navigateLeft() {
                    const currentSectionItems = this.getCurrentSectionItems();
                    if (currentSectionItems && this.currentItem > 0) {
                        this.currentItem--;
                        this.focusCurrentItem();
                        this.scrollToCurrentItem();
                    }
                },

                navigateRight() {
                    const currentSectionItems = this.getCurrentSectionItems();
                    if (currentSectionItems && this.currentItem < currentSectionItems.length - 1) {
                        this.currentItem++;
                        this.focusCurrentItem();
                        this.scrollToCurrentItem();
                    }
                },

                getCurrentSectionItems() {
                    const section = this.sections[this.currentSection];
                    switch (section) {
                        case 'search':
                            // Always allow navigation to search box, even with no results
                            return this.results.length > 0 ? this.results : ['search-placeholder'];
                        case 'watchlist':
                            return this.watchlist;
                        case 'continue-watching':
                            return this.continueWatching;
                        case 'trending':
                            return this.getFilteredTrending();
                        case 'popular-movies':
                            return this.getFilteredPopularMovies();
                        case 'top-rated-movies':
                            return this.getFilteredTopRatedMovies();
                        case 'popular-tv-shows':
                            return this.getFilteredPopularTVShows();
                        case 'top-rated-tv-shows':
                            return this.getFilteredTopRatedTVShows();
                        case 'hindi':
                            return this.getFilteredHindi();
                        case 'bottom-navigation':
                            // Bottom navigation has 2 items: home and search
                            return ['home-button', 'search-button'];
                        default:
                            return null;
                    }
                },

                focusCurrentItem() {
                    // Clear previous focus
                    this.clearFocus();

                    // Add focus to current section
                    setTimeout(() => {
                        const section = this.sections[this.currentSection];

                        // Skip highlighting for search box as it has its own focus styles
                        if (section === 'search') {
                            if (this.results.length > 0) {
                                // Focus results if available
                                const container = document.getElementById('results-container');
                                if (container) {
                                    container.classList.add('tv-focused-section');
                                    const items = container.querySelectorAll('.tv-navigable-item');
                                    if (items[this.currentItem]) {
                                        items[this.currentItem].classList.add('tv-focused-item');
                                    }
                                }
                            } else {
                                // Focus the search input instead (but not on mobile to avoid keyboard popup)
                                const searchInput = document.querySelector('.search-input');
                                if (searchInput) {
                                    searchInput.classList.add('tv-focused-item');
                                    if (!this.isMobileDevice()) {
                                        searchInput.focus();
                                    }
                                }
                            }
                            return;
                        }

                        if (section === 'bottom-navigation') {
                            // Focus bottom navigation buttons
                            const bottomNavButtons = document.querySelectorAll('.fixed.bottom-0 .tv-navigable-item');
                            if (bottomNavButtons[this.currentItem]) {
                                bottomNavButtons[this.currentItem].classList.add('tv-focused-item');
                            }
                            return;
                        }

                        const container = document.getElementById(`${section}-container`);
                        if (container) {
                            // container.classList.add('tv-focused-section'); // Removed to only highlight cards, not background

                            // Focus specific item if it exists
                            const items = container.querySelectorAll('.tv-navigable-item');
                            if (items[this.currentItem]) {
                                items[this.currentItem].classList.add('tv-focused-item');
                            }
                        }
                    }, 10);
                },

                clearFocus() {
                    // Clear all focus classes
                    document.querySelectorAll('.tv-focused-section').forEach(el => {
                        el.classList.remove('tv-focused-section');
                    });
                    document.querySelectorAll('.tv-focused-item').forEach(el => {
                        el.classList.remove('tv-focused-item');
                    });
                },

                scrollToCurrentItem() {
                    const section = this.sections[this.currentSection];
                    const container = section === 'search' ? document.getElementById('results-container') : document.getElementById(`${section}-container`);
                    if (container) {
                        const items = container.querySelectorAll('.tv-navigable-item');
                        if (items[this.currentItem]) {
                            const item = items[this.currentItem];
                            const containerRect = container.getBoundingClientRect();
                            const itemRect = item.getBoundingClientRect();

                            if (itemRect.left < containerRect.left) {
                                container.scrollBy({ left: itemRect.left - containerRect.left - 20, behavior: 'smooth' });
                            } else if (itemRect.right > containerRect.right) {
                                container.scrollBy({ left: itemRect.right - containerRect.right + 20, behavior: 'smooth' });
                            }
                        }
                    }
                },

                scrollToCurrentSection() {
                    const section = this.sections[this.currentSection];
                    console.log('Scrolling to section:', section);

                    // Find the section element based on the section name
                    let sectionElement = null;
                    let scrollTarget = null;

                    switch (section) {
                        case 'search':
                            if (this.results.length > 0) {
                                sectionElement = document.querySelector('[x-show*="results.length > 0"]');
                            } else {
                                sectionElement = document.querySelector('[x-show="showSearchBar"]');
                            }
                            break;
                        case 'watchlist':
                            sectionElement = document.querySelector('[x-show*="showWatchlist"]');
                            scrollTarget = document.getElementById('watchlist-container');
                            break;
                        case 'continue-watching':
                            sectionElement = document.querySelector('[x-show*="showContinueWatching"]');
                            scrollTarget = document.getElementById('continue-watching-container');
                            break;
                        case 'trending':
                            sectionElement = document.querySelector('[x-show*="showTrending"]');
                            scrollTarget = document.getElementById('trending-container');
                            break;
                        case 'popular-movies':
                            sectionElement = document.querySelector('[x-show*="showPopularMovies"]');
                            scrollTarget = document.getElementById('popular-movies-container');
                            break;
                        case 'top-rated-movies':
                            sectionElement = document.querySelector('[x-show*="showTopRatedMovies"]');
                            scrollTarget = document.getElementById('top-rated-movies-container');
                            break;
                        case 'popular-tv-shows':
                            sectionElement = document.querySelector('[x-show*="showPopularTVShows"]');
                            scrollTarget = document.getElementById('popular-tv-container');
                            break;
                        case 'top-rated-tv-shows':
                            sectionElement = document.querySelector('[x-show*="showTopRatedTVShows"]');
                            scrollTarget = document.getElementById('top-rated-tv-container');
                            break;
                        case 'hindi':
                            sectionElement = document.querySelector('[x-show*="showHindi"]');
                            scrollTarget = document.getElementById('hindi-container');
                            break;
                        case 'bottom-navigation':
                            // Scroll to bottom to show bottom navigation
                            console.log('Scrolling to bottom navigation');
                            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                            return;
                    }

                    // Use the scroll target if available, otherwise use the section element
                    const targetElement = scrollTarget || sectionElement;
                    console.log('Target element found:', targetElement);

                    if (targetElement) {
                        // Use scrollIntoView for more reliable scrolling
                        targetElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start',
                            inline: 'nearest'
                        });

                        // Also ensure the page scrolls if needed
                        const elementRect = targetElement.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;

                        console.log('Element rect:', elementRect, 'Viewport height:', viewportHeight);

                        // If element is not visible enough, scroll the page
                        if (elementRect.top < 100 || elementRect.bottom > viewportHeight - 100) {
                            const scrollY = window.scrollY + elementRect.top - 150;
                            console.log('Additional page scroll needed to:', scrollY);
                            window.scrollTo({
                                top: Math.max(0, scrollY),
                                behavior: 'smooth'
                            });
                        }
                    } else {
                        console.log('No target element found for section:', section);
                    }
                },

                selectCurrentItem() {
                    const section = this.sections[this.currentSection];

                    // Special handling for search box
                    if (section === 'search') {
                        if (this.results.length > 0) {
                            if (this.results[this.currentItem]) {
                                this.watchContent(this.results[this.currentItem]);
                            }
                        } else {
                            // Focus search input (but not on mobile to avoid keyboard popup)
                            if (!this.isMobileDevice()) {
                                const searchInput = document.querySelector('.search-input');
                                if (searchInput) {
                                    searchInput.focus();
                                }
                            }
                        }
                        return;
                    }

                    if (section === 'bottom-navigation') {
                        if (this.currentItem === 0) {
                            // Home button - scroll to top and reset navigation
                            this.navigateToHome();
                        } else if (this.currentItem === 1) {
                            // Search button - open search overlay
                            this.toggleSearch();
                        }
                        return;
                    }

                    const currentSectionItems = this.getCurrentSectionItems();
                    if (currentSectionItems && currentSectionItems[this.currentItem]) {
                        this.watchContent(currentSectionItems[this.currentItem]);
                    }
                },

                focusSearch() {
                    const searchInput = document.querySelector('.search-input');
                    if (searchInput) {
                        searchInput.focus();
                        searchInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                toggleSearch() {
                    this.showSearch = !this.showSearch;
                    if (this.showSearch) {
                        // Reset navigation for search overlay
                        this.currentItem = 0;
                        // Focus the search input when opening with a slight delay for transition
                        setTimeout(() => {
                            const searchInput = this.$refs.searchOverlayInput;
                            if (searchInput) {
                                searchInput.focus();
                                // Ensure keyboard opens on mobile by clicking the input
                                searchInput.click();
                            }
                        }, 350); // Wait for transition to complete
                    } else {
                        // Clear search when closing
                        this.searchQuery = '';
                        this.results = [];
                    }
                },

                focusSearchResult() {
                    // Clear previous focus
                    document.querySelectorAll('.tv-focused-item').forEach(el => {
                        el.classList.remove('tv-focused-item');
                    });

                    // Focus current search result
                    const searchResults = document.querySelectorAll('.search-overlay .cursor-pointer');
                    if (searchResults[this.currentItem]) {
                        searchResults[this.currentItem].classList.add('tv-focused-item');
                        searchResults[this.currentItem].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                // Modal navigation methods
                navigateModalUp() {
                    if (this.modalCurrentItem > 0) {
                        this.modalCurrentItem--;
                        this.focusModalItem();
                    }
                },

                navigateModalDown() {
                    if (this.modalCurrentItem < this.modalItems.length - 1) {
                        this.modalCurrentItem++;
                        this.focusModalItem();
                    }
                },

                navigateModalLeft() {
                    // For modal, left/right might not be needed, but could be used for different layouts
                    // For now, just keep it simple
                },

                navigateModalRight() {
                    // For modal, left/right might not be needed, but could be used for different layouts
                    // For now, just keep it simple
                },

                focusModalItem() {
                    // Clear previous focus
                    document.querySelectorAll('.tv-focused-item').forEach(el => {
                        el.classList.remove('tv-focused-item');
                    });

                    // Focus current modal item
                    if (this.modalItems[this.modalCurrentItem]) {
                        const item = this.modalItems[this.modalCurrentItem];
                        item.classList.add('tv-focused-item');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                },

                selectModalItem() {
                    if (this.modalItems[this.modalCurrentItem]) {
                        const item = this.modalItems[this.modalCurrentItem];
                        console.log('Selecting modal item:', this.modalCurrentItem, item);

                        // Check if this is the close button
                        if (item.classList.contains('absolute')) {
                            console.log('Close button selected, closing modal');
                            this.closeModal();
                            return;
                        }

                        // Check if this is a button and trigger the appropriate action
                        if (item.tagName === 'BUTTON') {
                            const clickHandler = item.getAttribute('@click') || item.getAttribute('onclick');
                            console.log('Button click handler:', clickHandler);

                            if (clickHandler) {
                                // For Alpine.js click handlers, we need to evaluate them
                                if (clickHandler.includes('playFullscreen()')) {
                                    console.log('Calling playFullscreen()');
                                    this.playFullscreen();
                                } else if (clickHandler.includes('toggleWatchlist(')) {
                                    console.log('Calling toggleWatchlist()');
                                    this.toggleWatchlist(this.selectedContent);
                                } else if (clickHandler.includes('toggleModalTrailerMute()')) {
                                    console.log('Calling toggleModalTrailerMute()');
                                    this.toggleModalTrailerMute();
                                } else if (clickHandler.includes('showEpisodeSelector')) {
                                    console.log('Toggling episode selector');
                                    this.showEpisodeSelector = !this.showEpisodeSelector;
                                    this.updateModalNavigation();
                                } else {
                                    // Fallback to regular click
                                    console.log('Using fallback click');
                                    item.click();
                                }
                            } else {
                                console.log('No click handler found, using click()');
                                item.click();
                            }
                        } else {
                            // For non-button elements (like episode items), trigger click
                            console.log('Non-button element, using click()');
                            item.click();
                        }
                    } else {
                        console.log('No modal item found at index:', this.modalCurrentItem);
                    }
                },

                navigateToHome() {
                    // Scroll to top
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    // Reset navigation to first section
                    this.currentSection = 0;
                    this.currentItem = 0;
                    this.focusCurrentItem();
                },

                updateModalNavigation() {
                    // Wait for modal content to be fully loaded
                    setTimeout(() => {
                        // Collect all navigable items in the modal - always get fresh references
                        this.modalItems = [];

                        // Get modal close button first
                        const closeButton = document.querySelector('.modal-content .tv-navigable-item.absolute');
                        if (closeButton) {
                            this.modalItems.push(closeButton);
                        }

                        // Get modal action buttons (Play, My List, Mute, Episodes)
                        const modalButtons = document.querySelectorAll('.modal-content button.tv-navigable-item:not(.absolute)');
                        modalButtons.forEach(button => {
                            this.modalItems.push(button);
                        });

                        // Get episode items if episode selector is shown
                        if (this.showEpisodeSelector) {
                            const episodeItems = document.querySelectorAll('.modal-content .grid .tv-navigable-item');
                            episodeItems.forEach(item => {
                                this.modalItems.push(item);
                            });
                        }

                        console.log('Modal navigation items found:', this.modalItems.length, 'showEpisodeSelector:', this.showEpisodeSelector);

                        // Reset modal navigation to first item
                        this.modalCurrentItem = 0;

                        // Focus the first item after a short delay to ensure DOM is ready
                        setTimeout(() => {
                            this.focusModalItem();
                        }, 100);
                    }, 200); // Reduced delay for faster navigation
                },

                isSectionVisible(section) {
                    // First check if the section has content
                    let hasContent = false;
                    switch (section) {
                        case 'search':
                            // Search section is always visible (can navigate to search input even without results)
                            hasContent = true;
                            break;
                        case 'watchlist':
                            hasContent = this.showWatchlist && this.getFilteredWatchlist().length > 0;
                            break;
                        case 'continue-watching':
                            hasContent = this.showContinueWatching && this.getFilteredContinueWatching().length > 0;
                            break;
                        case 'trending':
                            hasContent = this.showTrending && (this.getFilteredTrending() || []).length > 0;
                            break;
                        case 'popular-movies':
                            hasContent = this.showPopularMovies && this.getFilteredPopularMovies().length > 0;
                            break;
                        case 'popular-tv-shows':
                            hasContent = this.showPopularTVShows && this.getFilteredPopularTVShows().length > 0;
                            break;
                        case 'top-rated-movies':
                            hasContent = this.showTopRatedMovies && this.getFilteredTopRatedMovies().length > 0;
                            break;
                        case 'top-rated-tv-shows':
                            hasContent = this.showTopRatedTVShows && this.getFilteredTopRatedTVShows().length > 0;
                            break;
                        case 'hindi':
                            hasContent = this.showHindi && this.getFilteredHindi().length > 0;
                            break;
                        case 'bottom-navigation':
                            hasContent = false; // Bottom navigation is hidden on desktop
                            break;
                        default:
                            hasContent = false;
                    }

                    if (!hasContent) return false;

                    // Then check if the section element is actually visible (not hidden by CSS)
                    let sectionElement = null;
                    switch (section) {
                        case 'search':
                            sectionElement = document.querySelector('[x-show="showSearchBar"]');
                            break;
                        case 'watchlist':
                            sectionElement = document.querySelector('[x-show*="showWatchlist"]');
                            break;
                        case 'continue-watching':
                            sectionElement = document.querySelector('[x-show*="showContinueWatching"]');
                            break;
                        case 'trending':
                            sectionElement = document.querySelector('[x-show*="showTrending"]');
                            break;
                        case 'popular-movies':
                            sectionElement = document.querySelector('[x-show*="showPopularMovies"]');
                            break;
                        case 'popular-tv-shows':
                            sectionElement = document.querySelector('[x-show*="showPopularTVShows"]');
                            break;
                        case 'top-rated-movies':
                            sectionElement = document.querySelector('[x-show*="showTopRatedMovies"]');
                            break;
                        case 'top-rated-tv-shows':
                            sectionElement = document.querySelector('[x-show*="showTopRatedTVShows"]');
                            break;
                        case 'hindi':
                            sectionElement = document.querySelector('[x-show*="showHindi"]');
                            break;
                    }

                    if (sectionElement) {
                        // Check if element is visible (not hidden by CSS)
                        const style = window.getComputedStyle(sectionElement);
                        return style.display !== 'none' && style.visibility !== 'hidden';
                    }

                    return hasContent; // Fallback for sections without specific elements
                },

                findFirstVisibleSection() {
                    for (let i = 0; i < this.sections.length; i++) {
                        if (this.isSectionVisible(this.sections[i])) {
                            return i;
                        }
                    }
                    return 0; // Fallback to first section
                },

                ensureValidNavigation() {
                    // If current section is not visible, move to first visible section
                    if (!this.isSectionVisible(this.sections[this.currentSection])) {
                        this.currentSection = this.findFirstVisibleSection();
                        this.currentItem = 0;
                        this.focusCurrentItem();
                        this.scrollToCurrentSection();
                    }
                },
            }
        }
    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Force fullscreen on PWA launch
        document.addEventListener('DOMContentLoaded', () => {
            // Check if running as PWA
            if (window.matchMedia('(display-mode: standalone)').matches ||
                window.navigator.standalone === true) {

                // Force fullscreen immediately
                const requestFullscreen = () => {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(() => { });
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        document.documentElement.msRequestFullscreen();
                    }
                };

                // Try immediately
                requestFullscreen();

                // Try again after a short delay to ensure it works
                setTimeout(requestFullscreen, 100);
                setTimeout(requestFullscreen, 500);
            }
        });
    </script>
</body>

</html>
</content>