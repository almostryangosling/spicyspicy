<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Watch - Spicy</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Spicy">
    <meta name="mobile-web-app-capable" content="yes">

    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cpath fill='%2300A86B' d='M16 2C12.1 2 9 5.1 9 9c0 1.4.4 2.7 1 3.8C8.7 13.8 7 15.8 7 18c0 3.9 3.1 7 7 7h4c3.9 0 7-3.1 7-7 0-2.2-1.7-4.2-3-5.2.6-1.1 1-2.4 1-3.8 0-3.9-3.1-7-7-7z'/%3E%3Cpath fill='%23008000' d='M16 4c2.8 0 5 2.2 5 5 0 1-.3 2-.8 2.8-.2.3-.4.6-.6.9-.5-.1-1-.2-1.6-.2-2.8 0-5 2.2-5 5 0 .6.1 1.1.3 1.6-.3-.2-.6-.4-.9-.6C12.3 17 12 16 12 15c0-2.8 2.2-5 5-5 .6 0 1.1.1 1.6.3-.2-.3-.4-.6-.6-.9C18.3 8.3 18 7 18 6c0-2.8 2.2-5 5-5z'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="appicon.jpg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.10.3/cdn.min.js" defer></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    backgroundColor: {
                        'amoled': '#000000',
                        'amoled-light': '#0A0A0A',
                        'amoled-card': '#121212',
                    },
                    borderColor: {
                        'amoled-border': '#1A1A1A',
                    },
                },
            },
        }
    </script>
    <style>
        .player-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            z-index: 1;
        }

        .player-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
            z-index: 2;
        }

        .source-button {
            transition: all 0.3s ease;
        }

        .source-button:hover {
            transform: translateY(-2px);
        }

        .source-button.active {
            background-color: #3b82f6;
            color: white;
        }

        .episode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        @media (min-width: 640px) {
            .episode-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                gap: 1rem;
            }
        }

        @media (min-width: 768px) {
            .episode-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        .episode-card {
            transition: all 0.3s ease;
        }

        .episode-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .episode-card.active {
            border: 2px solid #3b82f6;
        }

        .trailer-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            border-radius: 0.5rem;
        }

        .trailer-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
            border-radius: 0.5rem;
        }

        /* Progressive loading animations */
        .fade-in {
            animation: fadeIn 0.3s ease-out forwards;
            opacity: 0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-delay-1 {
            animation-delay: 0.1s;
        }

        .fade-in-delay-2 {
            animation-delay: 0.2s;
        }

        .fade-in-delay-3 {
            animation-delay: 0.3s;
        }

        /* Page transition animations */
        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .page-transition-out {
            animation: fadeOut 0.25s ease-out forwards;
        }

        .page-transition-in {
            animation: fadeIn 0.3s ease-in;
        }

        /* Netflix/Hulu/Prime-inspired card animations */
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .card-animate {
            animation: fadeInScale 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        .card-animate-slide-left {
            animation: slideInFromLeft 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        .card-animate-slide-right {
            animation: slideInFromRight 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            opacity: 0;
        }

        /* Staggered animation delays for cards */
        .card-delay-1 {
            animation-delay: 0.05s;
        }

        .card-delay-2 {
            animation-delay: 0.1s;
        }

        .card-delay-3 {
            animation-delay: 0.15s;
        }

        .card-delay-4 {
            animation-delay: 0.2s;
        }

        .card-delay-5 {
            animation-delay: 0.25s;
        }

        .card-delay-6 {
            animation-delay: 0.3s;
        }

        .card-delay-7 {
            animation-delay: 0.35s;
        }

        .card-delay-8 {
            animation-delay: 0.4s;
        }

        .card-delay-9 {
            animation-delay: 0.45s;
        }

        .card-delay-10 {
            animation-delay: 0.5s;
        }

        .card-delay-11 {
            animation-delay: 0.55s;
        }

        .card-delay-12 {
            animation-delay: 0.6s;
        }

        .card-delay-13 {
            animation-delay: 0.65s;
        }

        .card-delay-14 {
            animation-delay: 0.7s;
        }

        .card-delay-15 {
            animation-delay: 0.75s;
        }

        .card-delay-16 {
            animation-delay: 0.8s;
        }

        .card-delay-17 {
            animation-delay: 0.85s;
        }

        .card-delay-18 {
            animation-delay: 0.9s;
        }

        .card-delay-19 {
            animation-delay: 0.95s;
        }

        .card-delay-20 {
            animation-delay: 1s;
        }

        .tv-navigable-item {
            transition: all 0.3s ease;
        }

        .tv-focused-section {
            position: relative;
        }

        .tv-focused-section::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 3px solid #ADD8E6;
            border-radius: 0.75rem;
            z-index: 10;
            pointer-events: none;
        }

        .tv-focused-section.tv-focused-player {
            position: relative;
        }

        .tv-focused-section.tv-focused-player::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(173, 216, 230, 0.1);
            border-radius: 0.5rem;
            z-index: 5;
            pointer-events: none;
            animation: playerPulse 2s ease-in-out infinite;
        }

        @keyframes playerPulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(173, 216, 230, 0.4);
            }

            50% {
                box-shadow: 0 0 0 4px rgba(173, 216, 230, 0);
            }
        }

        .tv-focused-item {
            position: relative;
            border: 2px solid #002cee;
            border-radius: 0.5rem;
            z-index: 10;
        }

        .episode-card.tv-focused-item {
            border: 2px solid #002cee;
            box-shadow: 0 0 10px rgba(0, 44, 238, 0.5);
        }

        .tv-focused-section.tv-focused-player::after {
            background: none;
            animation: none;
        }
    </style>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</head>

<body class="bg-amoled min-h-screen text-white" x-data="watchApp()">

    <!-- Home Button - Top Left Corner -->
    <div class="fixed top-4 left-2 sm:top-6 sm:left-4 z-50">
        <a href="#" @click.prevent="navigateWithTransition('index.html')"
            class="tv-navigable-item hidden sm:inline-flex items-center px-3 py-1.5 sm:px-4 sm:py-2 bg-black text-white border border-gray-600 rounded-lg hover:bg-gray-900 hover:border-gray-500 transition-all duration-200 shadow-lg text-sm sm:text-base font-semibold">
            Home
        </a>
    </div>

    <!-- Search Overlay -->
    <div x-show="showSearch" class="fixed inset-0 bg-amoled bg-opacity-95 z-50 p-4 flex flex-col"
        @click.self="toggleSearch()" x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0">
        <div class="relative mb-6 mt-4">
            <input type="text" x-model="searchQuery" @keyup.debounce.500ms="searchContent()"
                @keyup.enter="searchContent()" placeholder="Search for movies, TV shows..."
                class="w-full py-3 pl-4 pr-10 border-b-2 border-gray-600 bg-transparent text-white text-lg focus:outline-none focus:border-blue-500 transition-colors"
                x-ref="searchOverlayInput">
            <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
            </div>
        </div>

        <!-- Loading State -->
        <div x-show="isLoading" class="flex justify-center items-center flex-grow" @click.stop>
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-400"></div>
        </div>

        <!-- Results -->
        <div x-show="!isLoading && searchResults.length > 0" class="flex-grow overflow-y-auto -mr-4 pr-4" @click.stop>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                <template x-for="(item, index) in searchResults" :key="item.id">
                    <div @click="watchContent(item)" class="cursor-pointer group card-animate"
                        :class="'card-delay-' + ((index % 20) + 1)">
                        <div class="relative aspect-[2/3] bg-amoled-card rounded-lg overflow-hidden">
                            <img :src="item.poster_path ? 'https://image.tmdb.org/t/p/w300' + item.poster_path : 'https://via.placeholder.com/300x450?text=No+Image'"
                                :alt="item.title || item.name"
                                class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                                @error="event => { event.target.src = 'https://via.placeholder.com/300x450?text=No+Image'; }">
                            <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                            <h3 class="absolute bottom-2 left-2 right-2 text-sm font-semibold text-white"
                                x-text="item.title || item.name"></h3>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- No Results -->
        <div x-show="!isLoading && searchQuery && searchResults.length === 0"
            class="flex flex-col justify-center items-center flex-grow text-center text-gray-400" @click.stop>
            <svg class="w-12 h-12 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.467-.881-6.08-2.33" />
            </svg>
            <p>No results found for "<span x-text="searchQuery" class="font-semibold text-gray-300"></span>"</p>
        </div>
    </div>

    <div class="container mx-auto px-2 sm:px-4 pt-2 pb-16 sm:py-8">
        <div class="w-full max-w-6xl mx-auto">
            <!-- Main Content -->
            <div class="w-full space-y-4 sm:space-y-6">
                <!-- Video Player -->
                <div id="player-section"
                    class="bg-amoled-card rounded-lg shadow-lg overflow-hidden border border-amoled-border fade-in">
                    <div class="player-container">
                        <iframe x-bind:src="currentVideoUrl" allowfullscreen></iframe>
                    </div>
                </div>

                <!-- Content Details -->
                <div id="info-section" x-show="content"
                    class="rounded-lg shadow-lg p-4 sm:p-6 border border-amoled-border fade-in fade-in-delay-1 relative">
                    <!-- Make it Work Button -->
                    <button @click="switchToAlternativeSource()"
                        class="absolute top-3 right-3 sm:top-4 sm:right-4 px-3 py-1.5 sm:px-4 sm:py-2 bg-transparent border border-gray-600 hover:border-gray-400 text-gray-400 hover:text-gray-200 rounded-lg text-xs sm:text-sm font-medium transition-all duration-200 focus:outline-none backdrop-blur-sm">
                        Make it Work
                    </button>
                    <div class="flex flex-col lg:flex-row gap-4 sm:gap-6">
                        <!-- Poster -->
                        <div class="flex-shrink-0">
                            <img :src="content.poster_path ? 'https://image.tmdb.org/t/p/w300' + content.poster_path : 'https://via.placeholder.com/300x450?text=No+Image'"
                                :alt="content.title || content.name" class="w-32 sm:w-40 lg:w-48 rounded-lg shadow-lg"
                                @error="event => { event.target.src = 'https://via.placeholder.com/300x450?text=No+Image'; }">
                        </div>

                        <!-- Details -->
                        <div class="flex-1 min-w-0">
                            <h1 class="text-xl sm:text-2xl lg:text-3xl font-bold text-white mb-2"
                                x-text="content.title || content.name"></h1>

                            <div class="flex flex-wrap items-center gap-2 sm:gap-4 mb-3 text-sm text-gray-300">
                                <span x-show="content.release_date || content.first_air_date" class="flex items-center">
                                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z">
                                        </path>
                                    </svg>
                                    <span
                                        x-text="new Date(content.release_date || content.first_air_date).getFullYear()"></span>
                                </span>

                                <span x-show="content.vote_average" class="flex items-center">
                                    <svg class="w-4 h-4 mr-1 text-yellow-400" fill="currentColor" viewBox="0 0 24 24">
                                        <path
                                            d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z">
                                        </path>
                                    </svg>
                                    <span x-text="content.vote_average.toFixed(1) + '/10'"></span>
                                </span>

                                <span x-show="content.runtime" class="flex items-center">
                                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <span x-text="content.runtime + ' min'"></span>
                                </span>

                                <span x-show="isShow && content.number_of_seasons" class="flex items-center">
                                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10">
                                        </path>
                                    </svg>
                                    <span
                                        x-text="content.number_of_seasons + ' Season' + (content.number_of_seasons > 1 ? 's' : '')"></span>
                                </span>
                            </div>

                            <div x-show="content.genres && content.genres.length > 0" class="flex flex-wrap gap-2 mb-4">
                                <template x-for="genre in content.genres" :key="genre.id">
                                    <span
                                        class="px-2 py-1 bg-blue-600/20 text-blue-300 rounded-full text-xs font-medium"
                                        x-text="genre.name"></span>
                                </template>
                            </div>

                            <p x-show="content.overview" class="text-gray-300 text-sm sm:text-base leading-relaxed mb-4"
                                x-text="content.overview"></p>
                        </div>
                    </div>
                </div>

                <!-- Episode Selector (for TV shows) -->
                <div id="episodes-section" x-show="isShow"
                    class="rounded-lg shadow-lg p-3 sm:p-6 border border-amoled-border fade-in fade-in-delay-2">
                    <h2 class="text-lg sm:text-xl font-bold mb-3 sm:mb-4 text-white">Episodes</h2>

                    <!-- Season Selector -->
                    <div class="mb-3 sm:mb-4">
                        <label class="block text-xs sm:text-sm font-medium text-gray-300 mb-2">Season</label>
                        <select x-model="selectedSeason" @change="loadEpisodes()"
                            class="w-full px-2 py-2 sm:px-3 sm:py-2 border border-amoled-border rounded-md bg-amoled-light text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm">
                            <template x-for="season in seasons" :key="season">
                                <option :value="season" x-text="'Season ' + season"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Episodes Grid -->
                    <div class="episode-grid" x-show="episodes.length > 0">
                        <template x-for="(episode, index) in episodes" :key="episode.episode_number">
                            <div class="tv-navigable-item episode-card bg-amoled-light rounded-lg p-2 sm:p-4 cursor-pointer border border-amoled-border hover:bg-amoled-card transition-colors card-animate-slide-left"
                                :class="[
                                    selectedEpisode === episode.episode_number ? 'active border-blue-500 bg-amoled-card' : '',
                                    'card-delay-' + ((index % 20) + 1)
                                ]" @click="selectEpisode(episode.episode_number)">
                                <div
                                    class="aspect-video mb-2 sm:mb-3 bg-gray-600 rounded flex items-center justify-center">
                                    <img :src="episode.still_path ? 'https://image.tmdb.org/t/p/w300' + episode.still_path : 'https://via.placeholder.com/300x169?text=Episode+' + episode.episode_number"
                                        :alt="'Episode ' + episode.episode_number"
                                        class="w-full h-full object-cover rounded"
                                        @error="event => { event.target.src = 'https://via.placeholder.com/300x169?text=Episode+' + episode.episode_number; }">
                                </div>
                                <h3 class="font-medium text-xs sm:text-sm mb-1 text-white"
                                    x-text="'Episode ' + episode.episode_number + ': ' + episode.name"></h3>
                                <p class="text-xs text-gray-400 line-clamp-2"
                                    x-text="episode.overview || 'No description available.'"></p>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- Trailer -->
                <div id="trailer-section" x-show="trailerUrl"
                    class="rounded-lg shadow-lg p-4 sm:p-6 border border-amoled-border fade-in fade-in-delay-3">
                    <h2 class="text-lg sm:text-xl font-bold text-white mb-4">Trailer</h2>
                    <div class="trailer-container">
                        <iframe :src="trailerUrl" allowfullscreen></iframe>
                    </div>
                </div>


            </div>
        </div>
    </div>

    <!-- Bottom Navigation (Mobile Only) -->
    <div
        class="fixed bottom-0 left-0 right-0 bg-amoled border-t border-amoled-border p-2 flex justify-around sm:hidden z-50">
        <a href="#" @click.prevent="navigateWithTransition('index.html')"
            class="flex flex-col items-center justify-center text-gray-300 hover:text-white transition-colors w-full py-2 rounded-lg hover:bg-amoled-card">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
        </a>
        <a href="#" @click.prevent="toggleSearch()"
            class="flex flex-col items-center justify-center text-gray-300 hover:text-white transition-colors w-full py-2 rounded-lg hover:bg-amoled-card">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
        </a>
        <a href="discover.html"
            class="flex flex-col items-center justify-center text-gray-300 hover:text-white transition-colors w-full py-2 rounded-lg hover:bg-amoled-card">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M7 4V2a1 1 0 011-1h8a1 1 0 011 1v2M7 4H5a2 2 0 00-2 2v10a2 2 0 002 2h14a2 2 0 002-2V6a2 2 0 00-2-2h-2M7 4h10" />
            </svg>
        </a>
    </div>

    <script>
        function watchApp() {
            return {
                content: null,
                contentId: null,
                contentType: null,
                isShow: false,
                selectedSeason: 1,
                selectedEpisode: 1,
                seasons: [],
                episodes: [],
                selectedSource: 'vidfast', // Hardcoded to VidFast
                useAlternativeSource: false, // Track if using VidKing instead of VidFast
                currentVideoUrl: '',
                // Additional content data
                trailerUrl: '',
                // Navigation properties
                currentSection: 0,
                currentItem: 0,
                sections: ['player', 'info', 'trailer', 'sources', 'home'], // Will be updated dynamically
                sourcesNavigationMode: false, // Track if we're navigating individual source buttons
                trailerPlaying: false, // Track if trailer is currently playing
                playerPlaying: false, // Track if main player is currently playing (best-effort)
                showSearch: false, // Track if search overlay is visible
                searchQuery: '',
                searchResults: [],
                isLoading: false,
                apiKey: '1070730380f5fee0d87cf0382670b255',
                minWatchTime: 10000, // 10 seconds minimum watch time to count as viewed
                playbackStarted: false,
                playbackTimer: null,
                hasConfirmedPlayback: false,

                init() {
                    const urlParams = new URLSearchParams(window.location.search);
                    this.contentId = urlParams.get('id');
                    this.contentType = urlParams.get('type');
                    const defaultSource = urlParams.get('defaultSource');

                    if (this.contentId && this.contentType) {
                        this.isShow = this.contentType === 'tv';
                        // Use default source if provided, otherwise use multiembed
                        this.selectedSource = defaultSource || 'multiembed';
                        this.loadContent();

                        // Setup playback tracking after content loads
                        setTimeout(() => {
                            this.setupPlaybackTracking();
                        }, 2000);

                        // Cleanup on page unload
                        window.addEventListener('beforeunload', () => {
                            this.stopPlaybackTracking();
                        });

                        // Initialize keyboard navigation
                        this.initKeyboardNavigation();

                        // Update sections based on content
                        this.updateSections();

                        // Initialize focus
                        setTimeout(() => {
                            this.focusCurrentItem();
                        }, 1000);
                    }

                    // Add page transition in animation
                    document.body.classList.add('page-transition-in');
                },

                // Page transition navigation
                navigateWithTransition(url) {
                    document.body.classList.add('page-transition-out');
                    setTimeout(() => {
                        window.location.href = url;
                    }, 250); // Match fadeOut duration
                },

                async loadContent() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/${this.contentType}/${this.contentId}?api_key=1070730380f5fee0d87cf0382670b255`);
                        const data = await response.json();
                        this.content = data;

                        // Load additional data
                        await this.loadTrailer();

                        if (this.isShow) {
                            this.seasons = Array.from({ length: data.number_of_seasons }, (_, i) => i + 1);
                            this.loadEpisodes();
                        } else {
                            this.updateVideoUrl();
                        }
                    } catch (error) {
                        console.error('Error loading content:', error);
                    }
                },

                async loadEpisodes() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/tv/${this.contentId}/season/${this.selectedSeason}?api_key=1070730380f5fee0d87cf0382670b255`);
                        const data = await response.json();
                        this.episodes = data.episodes || [];
                        this.selectedEpisode = 1;
                        this.updateVideoUrl();
                        this.updateSections();
                    } catch (error) {
                        console.error('Error loading episodes:', error);
                    }
                },

                async loadTrailer() {
                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/${this.contentType}/${this.contentId}/videos?api_key=1070730380f5fee0d87cf0382670b255`);
                        const data = await response.json();

                        const trailer = data.results?.find(video =>
                            video.type === 'Trailer' &&
                            video.site === 'YouTube' &&
                            video.official === true
                        ) || data.results?.find(video =>
                            video.type === 'Trailer' && video.site === 'YouTube'
                        );

                        if (trailer) {
                            this.trailerUrl = `https://www.youtube.com/embed/${trailer.key}?enablejsapi=1`;
                            this.updateSections();
                        }
                    } catch (error) {
                        console.error('Error loading trailer:', error);
                        this.trailerUrl = '';
                    }
                },

                selectEpisode(episodeNumber) {
                    this.selectedEpisode = episodeNumber;
                    this.updateVideoUrl();
                },



                updateVideoUrl() {
                    let url;

                    if (this.useAlternativeSource) {
                        // Use VidKing as alternative source
                        if (this.isShow) {
                            url = `https://www.vidking.net/embed/tv/${this.contentId}/${this.selectedSeason}/${this.selectedEpisode}`;
                        } else {
                            url = `https://www.vidking.net/embed/movie/${this.contentId}`;
                        }
                    } else {
                        // Use VidFast as default source
                        if (this.isShow) {
                            url = `https://vidfast.pro/tv/${this.contentId}/${this.selectedSeason}/${this.selectedEpisode}?autoPlay=true`;
                        } else {
                            url = `https://vidfast.pro/movie/${this.contentId}?autoPlay=true`;
                        }
                    }

                    this.currentVideoUrl = url;

                    // Reset playback tracking for new video
                    this.hasConfirmedPlayback = false;
                    this.stopPlaybackTracking();

                    // Reset our best-effort player state on URL change
                    this.playerPlaying = false;

                    // Setup tracking for new video
                    this.setupPlaybackTracking();
                },

                switchToAlternativeSource() {
                    // Toggle to alternative source (VidKing)
                    this.useAlternativeSource = true;
                    this.updateVideoUrl();
                    console.log('Switched to alternative source (VidKing):', this.currentVideoUrl);
                },

                // Playback tracking functions
                startPlaybackTracking() {
                    if (this.hasConfirmedPlayback) return;

                    this.playbackStarted = true;

                    // Set timer for minimum watch time
                    this.playbackTimer = setTimeout(() => {
                        this.confirmPlayback();
                    }, this.minWatchTime);

                    console.log('Started playback tracking for:', this.content?.title || this.content?.name);
                },

                stopPlaybackTracking() {
                    if (this.playbackTimer) {
                        clearTimeout(this.playbackTimer);
                        this.playbackTimer = null;
                    }
                    this.playbackStarted = false;
                },

                confirmPlayback() {
                    if (this.hasConfirmedPlayback) return;

                    this.hasConfirmedPlayback = true;
                    this.stopPlaybackTracking();

                    // Send data to index.html
                    const continueWatchingData = {
                        id: this.contentId,
                        title: this.content.title || this.content.name,
                        media_type: this.contentType,
                        poster_path: this.content.poster_path,
                        release_date: this.content.release_date || this.content.first_air_date,
                        vote_average: this.content.vote_average,
                        overview: this.content.overview
                    };

                    localStorage.setItem('streamSearch_continueWatching_update', JSON.stringify(continueWatchingData));

                    console.log('Playback confirmed, added to Continue Watching:', continueWatchingData.title);
                },

                setupPlaybackTracking() {
                    // Wait for iframe to load
                    setTimeout(() => {
                        const iframe = document.querySelector('.player-container iframe');
                        if (iframe) {
                            iframe.addEventListener('load', () => {
                                console.log('Video iframe loaded, starting playback tracking');
                                // Start tracking when iframe loads (indicates video is ready)
                                this.startPlaybackTracking();
                            });

                            // Also start tracking if iframe already has a src
                            if (iframe.src && iframe.src !== 'about:blank') {
                                this.startPlaybackTracking();
                            }
                        }
                    }, 1000);
                },

                initKeyboardNavigation() {
                    document.addEventListener('keydown', (e) => {
                        switch (e.key) {
                            case 'ArrowUp':
                                e.preventDefault();
                                this.navigateUp();
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                this.navigateDown();
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.navigateLeft();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.navigateRight();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                this.selectCurrentItem();
                                break;
                        }
                    });
                },

                navigateUp() {
                    if (this.currentSection > 0) {
                        this.currentSection--;
                    } else {
                        // Loop to the last section
                        this.currentSection = this.sections.length - 1;
                    }
                    this.currentItem = 0;

                    // Close sources panel when navigating away
                    if (this.sections[this.currentSection] !== 'sources') {
                        this.showSources = false;
                    }

                    // Reset trailer playing state when navigating away
                    if (this.sections[this.currentSection] !== 'trailer') {
                        this.trailerPlaying = false;
                    }

                    this.focusCurrentItem();
                    this.scrollToCurrentSection();
                },

                navigateDown() {
                    if (this.currentSection < this.sections.length - 1) {
                        this.currentSection++;
                    } else {
                        // Loop to the first section
                        this.currentSection = 0;
                    }
                    this.currentItem = 0;

                    // Close sources panel when navigating away
                    if (this.sections[this.currentSection] !== 'sources') {
                        this.showSources = false;
                    }

                    // Reset trailer playing state when navigating away
                    if (this.sections[this.currentSection] !== 'trailer') {
                        this.trailerPlaying = false;
                    }

                    this.focusCurrentItem();
                    this.scrollToCurrentSection();
                },

                navigateLeft() {
                    const currentSectionItems = this.getCurrentSectionItems();
                    // Only allow left navigation if there are multiple items
                    if (currentSectionItems && currentSectionItems.length > 1 && this.currentItem > 0) {
                        this.currentItem--;
                        this.focusCurrentItem();
                        this.scrollToCurrentItem();
                    }
                },

                navigateRight() {
                    const currentSectionItems = this.getCurrentSectionItems();
                    // Only allow right navigation if there are multiple items
                    if (currentSectionItems && currentSectionItems.length > 1 && this.currentItem < currentSectionItems.length - 1) {
                        this.currentItem++;
                        this.focusCurrentItem();
                        this.scrollToCurrentItem();
                    }
                },

                getCurrentSectionItems() {
                    const section = this.sections[this.currentSection];
                    switch (section) {
                        case 'player':
                            return ['player'];
                        case 'info':
                            return ['info'];
                        case 'episodes':
                            if (this.isShow && this.episodes.length > 0) {
                                return ['season-selector', ...this.episodes];
                            }
                            return null;
                        case 'trailer':
                            return this.trailerUrl ? ['trailer'] : null;
                        case 'sources':
                            // If sources panel is open, return individual source buttons
                            if (this.showSources) {
                                return this.availableSources;
                            } else {
                                return ['sources-header']; // Return header when panel is closed
                            }
                        case 'home':
                            return ['home-button'];
                        default:
                            return null;
                    }
                },

                focusCurrentItem() {
                    // Clear previous focus
                    this.clearFocus();

                    // Add focus to current section
                    setTimeout(() => {
                        const section = this.sections[this.currentSection];

                        if (section === 'home') {
                            const homeButton = document.querySelector('.fixed.top-4 a');
                            if (homeButton) {
                                homeButton.classList.add('tv-focused-item');
                            }
                            return;
                        }

                        if (section === 'player' || section === 'info') {
                            const container = document.getElementById(`${section}-section`);
                            if (container) {
                                container.classList.add('tv-focused-section');
                                if (section === 'player') {
                                    container.classList.add('tv-focused-player');
                                }
                            }
                            return;
                        }

                        if (section === 'episodes') {
                            const container = document.getElementById('episodes-section');
                            if (container) {
                                container.classList.add('tv-focused-section');
                                if (this.currentItem === 0) {
                                    // Focus season selector
                                    const seasonSelect = container.querySelector('select');
                                    if (seasonSelect) {
                                        seasonSelect.focus();
                                        seasonSelect.classList.add('tv-focused-item');
                                    }
                                } else {
                                    // Focus episode card
                                    const episodeIndex = this.currentItem - 1;
                                    const episodeCards = container.querySelectorAll('.episode-card');
                                    if (episodeCards[episodeIndex]) {
                                        episodeCards[episodeIndex].classList.add('tv-focused-item');
                                    }
                                }
                            }
                            return;
                        }

                        const container = document.getElementById(`${section}-section`);
                        if (container) {
                            container.classList.add('tv-focused-section');

                            // Focus specific item if it exists
                            const items = container.querySelectorAll('.tv-navigable-item');
                            if (items[this.currentItem]) {
                                items[this.currentItem].classList.add('tv-focused-item');
                            }

                            // Special handling for sources section
                            if (section === 'sources' && !this.showSources) {
                                // If sources panel is closed, highlight the header area
                                const headerElement = container.querySelector('h2');
                                if (headerElement) {
                                    headerElement.classList.add('tv-focused-item');
                                }
                            }
                        }
                    }, 10);
                },

                clearFocus() {
                    // Clear all focus classes
                    document.querySelectorAll('.tv-focused-section').forEach(el => {
                        el.classList.remove('tv-focused-section');
                        el.classList.remove('tv-focused-player');
                    });
                    document.querySelectorAll('.tv-focused-item').forEach(el => {
                        el.classList.remove('tv-focused-item');
                    });
                },

                scrollToCurrentItem() {
                    const section = this.sections[this.currentSection];

                    // Skip scrolling for sections without multiple items
                    if (section === 'player' || section === 'info' || section === 'home') {
                        return;
                    }

                    if (section === 'episodes') {
                        const container = document.getElementById('episodes-section');
                        if (container) {
                            if (this.currentItem === 0) {
                                // Scroll to season selector
                                const seasonSelect = container.querySelector('select');
                                if (seasonSelect) {
                                    seasonSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            } else {
                                // Scroll to episode card
                                const episodeIndex = this.currentItem - 1;
                                const episodeCards = container.querySelectorAll('.episode-card');
                                if (episodeCards[episodeIndex]) {
                                    episodeCards[episodeIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }
                        }
                        return;
                    }

                    const container = document.getElementById(`${section}-section`);
                    if (container) {
                        const items = container.querySelectorAll('.tv-navigable-item');
                        if (items[this.currentItem]) {
                            const item = items[this.currentItem];
                            const containerRect = container.getBoundingClientRect();
                            const itemRect = item.getBoundingClientRect();

                            if (itemRect.left < containerRect.left) {
                                container.scrollBy({ left: itemRect.left - containerRect.left - 20, behavior: 'smooth' });
                            } else if (itemRect.right > containerRect.right) {
                                container.scrollBy({ left: itemRect.right - containerRect.right + 20, behavior: 'smooth' });
                            }
                        }
                    }
                },

                scrollToCurrentSection() {
                    const section = this.sections[this.currentSection];

                    let sectionElement = null;

                    switch (section) {
                        case 'home':
                            sectionElement = document.querySelector('.fixed.top-4 a');
                            break;
                        case 'player':
                            sectionElement = document.getElementById('player-section');
                            break;
                        case 'info':
                            sectionElement = document.getElementById('info-section');
                            break;
                        case 'trailer':
                            sectionElement = document.getElementById('trailer-section');
                            break;
                        case 'sources':
                            // Don't scroll if sources panel is closed
                            if (!this.showSources) {
                                return;
                            }
                            sectionElement = document.getElementById('sources-section');
                            break;
                    }

                    if (sectionElement) {
                        const elementRect = sectionElement.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;

                        if (elementRect.top < 120) {
                            window.scrollBy({
                                top: elementRect.top - 150,
                                behavior: 'smooth'
                            });
                        } else if (elementRect.bottom > viewportHeight - 120) {
                            window.scrollBy({
                                top: elementRect.bottom - viewportHeight + 150,
                                behavior: 'smooth'
                            });
                        }
                    }
                },

                updateSections() {
                    const oldSection = this.sections[this.currentSection];
                    this.sections = ['player', 'info'];

                    if (this.isShow) {
                        this.sections.push('episodes');
                    }

                    if (this.trailerUrl) {
                        this.sections.push('trailer');
                    }

                    this.sections.push('sources', 'home');

                    // Adjust current section if it no longer exists
                    const currentSectionIndex = this.sections.indexOf(oldSection);
                    if (currentSectionIndex === -1) {
                        this.currentSection = 0;
                        this.currentItem = 0;
                    } else {
                        this.currentSection = currentSectionIndex;
                    }
                },

                selectCurrentItem() {
                    const section = this.sections[this.currentSection];

                    if (section === 'home') {
                        this.navigateWithTransition('index.html');
                        return;
                    }

                    if (section === 'player') {
                        // Focus the player iframe and try to toggle play/pause
                        const playerIframe = document.querySelector('.player-container iframe');
                        if (playerIframe) {
                            playerIframe.focus();

                            // Best-effort control via postMessage (some players ignore this)
                            try {
                                if (playerIframe.contentWindow) {
                                    if (!this.playerPlaying) {
                                        // Try a few common play commands
                                        playerIframe.contentWindow.postMessage('play', '*');
                                        playerIframe.contentWindow.postMessage({ action: 'play' }, '*');
                                        playerIframe.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                                    } else {
                                        playerIframe.contentWindow.postMessage('pause', '*');
                                        playerIframe.contentWindow.postMessage({ action: 'pause' }, '*');
                                        playerIframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                                    }
                                }
                            } catch (e) {
                                // Ignore cross-origin issues
                            }

                            // Fallback: toggle autoplay param to start/stop playback (resets stream)
                            const src = playerIframe.src;
                            const setParam = (url, key, value) => {
                                try {
                                    const u = new URL(url, window.location.origin);
                                    if (value === null) {
                                        u.searchParams.delete(key);
                                    } else {
                                        u.searchParams.set(key, value);
                                    }
                                    return u.toString();
                                } catch (_) {
                                    // Simple fallback manipulations
                                    const hasQuery = url.includes('?');
                                    const re = new RegExp('([?&])' + key + '=.*?(&|$)', 'i');
                                    if (value === null) {
                                        if (url.match(re)) {
                                            const cleaned = url.replace(re, (m, p1, p2) => (p2 === '&' ? p1 : ''));
                                            return cleaned.replace(/[?&]$/, '');
                                        }
                                        return url;
                                    }
                                    if (url.match(re)) return url.replace(re, `$1${key}=${value}$2`);
                                    return url + (hasQuery ? '&' : '?') + key + '=' + value;
                                }
                            };

                            if (!this.playerPlaying) {
                                const newSrc = setParam(src, 'autoplay', '1');
                                if (newSrc !== src) playerIframe.src = newSrc;
                                this.playerPlaying = true;
                            } else {
                                // Remove autoplay to effectively stop playback (will reset)
                                const newSrc = setParam(src, 'autoplay', null);
                                if (newSrc !== src) playerIframe.src = newSrc;
                                this.playerPlaying = false;
                            }
                        }
                        return;
                    }

                    if (section === 'info') {
                        // Info section is just for display, maybe scroll to top of info
                        const infoSection = document.getElementById('info-section');
                        if (infoSection) {
                            infoSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                        return;
                    }

                    if (section === 'episodes') {
                        const currentSectionItems = this.getCurrentSectionItems();
                        if (currentSectionItems && this.currentItem > 0) {
                            const episode = currentSectionItems[this.currentItem];
                            if (episode && episode.episode_number) {
                                this.selectEpisode(episode.episode_number);
                            }
                        }
                        // For season selector (currentItem === 0), do nothing as it's already focused
                        return;
                    }

                    if (section === 'trailer') {
                        // Focus the trailer iframe
                        const trailerIframe = document.querySelector('.trailer-container iframe');
                        if (trailerIframe) {
                            trailerIframe.focus();

                            if (!this.trailerPlaying) {
                                // Trailer is not playing, start it
                                // Method 1: Try to send play command to YouTube iframe
                                try {
                                    if (trailerIframe.contentWindow) {
                                        trailerIframe.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                                    }
                                } catch (e) {
                                    console.log('PostMessage failed');
                                }

                                // Method 2: Dispatch click event
                                try {
                                    const clickEvent = new MouseEvent('click', {
                                        bubbles: true,
                                        cancelable: true,
                                        view: window
                                    });
                                    trailerIframe.dispatchEvent(clickEvent);
                                } catch (e) {
                                    console.log('Click dispatch failed');
                                }

                                // Method 3: Reload with autoplay parameters
                                const currentSrc = trailerIframe.src;
                                if (!currentSrc.includes('autoplay=1')) {
                                    const autoplayUrl = currentSrc + (currentSrc.includes('?') ? '&' : '?') + 'autoplay=1';
                                    trailerIframe.src = autoplayUrl;
                                }

                                this.trailerPlaying = true;
                            } else {
                                // Trailer is playing, pause it
                                try {
                                    if (trailerIframe.contentWindow) {
                                        trailerIframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                                    }
                                } catch (e) {
                                    console.log('Pause PostMessage failed');
                                }
                                this.trailerPlaying = false;
                            }
                        }
                        return;
                    }

                    if (section === 'sources') {
                        if (!this.showSources) {
                            // Open the sources panel
                            this.showSources = true;
                            // Reset to first item and focus it
                            this.currentItem = 0;
                            setTimeout(() => {
                                this.focusCurrentItem();
                                this.scrollToCurrentItem();
                            }, 100);
                        } else {
                            // Select the focused source button
                            const currentSectionItems = this.getCurrentSectionItems();
                            if (currentSectionItems && currentSectionItems[this.currentItem]) {
                                const item = currentSectionItems[this.currentItem];
                                this.changeSource(item.id);
                            }
                        }
                    }
                },

                // Search functionality
                toggleSearch() {
                    this.showSearch = !this.showSearch;
                    if (this.showSearch) {
                        // Focus the search input when opening with a slight delay for transition
                        setTimeout(() => {
                            const searchInput = this.$refs.searchOverlayInput;
                            if (searchInput) {
                                searchInput.focus();
                                // Ensure keyboard opens on mobile by clicking the input
                                searchInput.click();
                            }
                        }, 350); // Wait for transition to complete
                    } else {
                        // Clear search when closing
                        this.searchQuery = '';
                        this.searchResults = [];
                    }
                },

                async searchContent() {
                    if (this.searchQuery.trim() === '') {
                        this.searchResults = [];
                        return;
                    }

                    this.isLoading = true;
                    this.searchResults = [];

                    try {
                        const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=1070730380f5fee0d87cf0382670b255&query=${encodeURIComponent(this.searchQuery)}`);
                        const data = await response.json();
                        this.searchResults = data.results.filter(item => item.media_type === 'movie' || item.media_type === 'tv') || [];
                    } catch (error) {
                        console.error('Error searching content:', error);
                    } finally {
                        this.isLoading = false;
                    }
                },

                watchContent(item) {
                    // Redirect to the content page with the selected item
                    const contentType = item.media_type === 'tv' ? 'tv' : 'movie';
                    this.navigateWithTransition(`watch.html?id=${item.id}&type=${contentType}`);
                },
            }
        }
    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // Force fullscreen on PWA launch
        document.addEventListener('DOMContentLoaded', () => {
            // Check if running as PWA
            if (window.matchMedia('(display-mode: standalone)').matches ||
                window.navigator.standalone === true) {

                // Force fullscreen immediately
                const requestFullscreen = () => {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(() => { });
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        document.documentElement.msRequestFullscreen();
                    }
                };

                // Try immediately
                requestFullscreen();

                // Try again after a short delay to ensure it works
                setTimeout(requestFullscreen, 100);
                setTimeout(requestFullscreen, 500);
            }
        });
    </script>
</body>

</html>